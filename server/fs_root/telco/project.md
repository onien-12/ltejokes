$$
\frac{1}{\sqrt{2}}
$$

# LTE и 5g NR и всякие другие штуки связанные с беспроводными системами связи

Прежде чем говорить о :glossary[LTE] и 5g NR стоит вообще понять какие проблемы эти системы пытаются решить. Другими словами, для чего они вообще были созданы? Можно конечно так сходу ответить: “ну логично же, чтобы можно было звонить, все дела”, но я тут имею ввиду скорее причины такой сложности этих технологий, почему нельзя сделать всё проще?

Так вот, давайте подумаем, каким все таки требованиям должны соответствовать сотовые системы связи. Для начала немного исторической справки.

С 2000 по 2010 год количество пользователей интернета, и, соответственно, сотовой связи выросло до 5 млрд. человек. Уже к 2010 году общий объем пакетных данных превысил общий объём голосовых данных в 10 раз. Этому способствовало в том числе развитие систем мобильных телекоммуникаций: WCDMA (2001), HSDPA (2007), HSUPA (2008) и HSPA+ (2010). К 2015 году ожидалось, что общее количество пользователей интернета составило бы более 5 млрд человек. К 2010 времени уже около 3 млрд. человек пользовались сотовыми системами для загрузки контента из интернета.

С ростом числа пользователей и ростом сложности интернет-приложений возросло и ожидание конечных клиентов от скорости соединения. Пользователи ожидали рост скорости обмена данными по радио так же, как она росла при проводном подключении. Стало очевидно, что необходимо разработать систему связи, которая бы обеспечила конечных пользователей быстрой скоростью обмена данными в двух направлениях (:glossary[uplink] и :glossary[downlink]).

Но тут вступают в силу практические ограничения. Во первых системы сотовой связи должны обеспечивать высокую мобильность, то есть обеспечивать нулевые потери данных при переходе из зоны действия одной вышки в другую. Тут надо учитывать огромное количество разных условий. Например Cell Interference, когда две вышки, работая на одинаковых частотах  создавают интерференцию (а это случается очень часто). Также надо учитывать само физическое ограничение радиосвязи, при котором потери сигнала могут быть такие, что не получится декодировать сигнал на базовой станции при переходе из одной зоны в другую. Сюда же добавляются сложности с организацией Antenna Array и Beamforming, CoMP и :glossary[Carrier Aggregation], сложности с быстрым изменение режимов :glossary[MIMO] и :glossary[Diversity], изменением метода модуляции и мультиплексирования.
Также базовые станции должны обслуживать огромное количество пользователей за раз, то есть управлять интерференцией, выделением ресурсов, MIMO и ограничивать пропускную способность канала RACH (который используется при подключении).
Кроме того, они должны работать быстро и стабильно, не разряжать батарею устройств, реализовывать шифрование и сжатие данных, повторную отправку пакетов и много чего ещё.

Именно поэтому читая тысячи страниц документации можно наталкиваться на, казалось бы, совершенно нелогичные вещи (например :glossary[PCFICH] или два режима RACH, Contention Based и Non Contention Based), но углубляясь и задумываясь, о том, для чего была внедрена такая сложность, становится понятно, что это не зря.

Давайте всё таки уже перейдем к технической части, а то вот это все не так интересно.

## Общая архитектура
```

        non-3gpp nets   ┌────┐  LTE-Uu                       
        ┌───────────────┤ UE ├─────────┐                     
        ▼               └────┘         │          E-UTRAN    
   ┌─────────┐                     ┌───▼────────────────┐    
   │ WIFI AP │                     │  eNB────X2────eNB  │    
   └────┬────┘                     └────────────────┬┬──┘    
┌───────┼───────────────────────────────────────────┼┼──────┐
│       ▼                                         S1││      │
│    ┌────┐              ┌───┐     S6a    ┌─────┐   ││      │
│    │ePDG├──────┐       │HSS│◄───────────┤ MME │◄──┘│      │
│    └──┬─┘      │       └───┘            └──┬──┘    │      │
│       │S2b     │SWm      ▲                 │       │S1-U  │
│       ▼        │         │SWx              │       │      │
│    ┌────┐      ▼       ┌─┴─┐               ▼       │      │
│    │P-GW├─────────────►│AAA│            ┌──────┐   │      │
│    └────┘      S6b     └───┘            │ S-GW │◄──┘      │
│                                         └──┬───┘          │
│                                            │              │
│                                            │S5/S8         │
│                                            ▼              │
│                               SGi       ┌──────┐          │
│                      ┌──────────────────┤PDN GW│          │
│                      │                  └──┬───┘          │
│                      ▼                     │Gx            │
│                ┌───────────┐               │              │
│                │           │               ▼              │
│                │  Service  │             ┌────┐           │
│                │    PDN    │             │PCEF│           │
│                │           │             └─┬──┘           │
│                └───────────┘               │Gx            │
│                     ▲                      ▼              │
│                     │          SGi       ┌────┐           │
│                     └────────────────────┤PCRF│           │
│EPC                                       └────┘           │
└───────────────────────────────────────────────────────────┘
```

Перед вами общая архитектура всей сети. На ней указаны интерфейсы и узлы системы, а также пути передачи данных. Рассмотрим некоторые узлы подробнее (потом все равно к ним вернемся когда будем говорить о EPS Bearer)
1. UE – User Equipment – устройство, подключающееся к вышкам сотовой связи (eNB) для коммуникации с PDN. Выполняет функции:
:::margin{ml=28}
 a) **Mobility Management** – осуществляет переход с одной обслуживающей eNB к другой (Handover)

 b) **Call Control** – осуществляет запрос нужных ресурсов для построения коммуникации с PDN

 c) **Identity Management** – устройство хранит данные для авторизации в сети: идентификаторы пользователя, ключи шифрования, и т.д.

 В целом, UE обеспечивает связь с сетью, выполняя задачи для поддержания соеденения. UE постоянно сообщает сети данные о качестве канала, требуемых действий и т.д. В общем именно сеть осуществляет управление UE, указывая модуляцию, кодировку и другие параметры, которые UE должен использовать при принятии или отправке данных.
:::
2. eNB – evolved NodeB – сама собственно вышка сотовой связи. Обеспечивает управление ресурсами, разделение каналов пользователей, отправкой данных в EPC, HARQ, RACH, Mobility Management, и т.д. Архитектурно, eNB выполняет функцию радиомоста между пользователем и EPC. Работа eNB подробно рассматривается далее. Все вышки объеденены в сеть (E-UTRAN (Evolved UMTS Radio Access Network)), между ними используется протокол X2.

3. EPC – evolved Packet Core – сеть оператора, обрабатывающая запросы с вышки, отправляющая их далее в интернет, либо в другие подключенные сети. Выполняет функции контроля (Control Plane Functions), Mobility Management, хранения данных о пользователях, установления EPS Bearer, и т.д. EPC состоит из следующих узлов:
:::margin{ml=28}
 a) **MME – Mobility Management Entity** – основной контроллирующий узел сети, работающий только в Control Plane, т.е никак не участвующий в передаче пользовательских данных. В его функции входят: управление авторизацией, Mobility Management, управление услугами оператора и планами тарифа, установление соеденения, и т.д. eNB передаёт данные на MME с помощью S1AP. Все функции этого узла будут подробнее описаны далее.

 b) **S-GW – Serving Gateway** – основной узел, отвечающий за отправку как пользовательских данных, так и данных eNB в E-UTRAN. В функции этого узла входят: Mobility Management (если интерфейс X2 недоступен, то данные между eNB будут идти через S-GW), Local Mobility Management (S-GW сохраняет S5/S8 Bearer при процедуре Handover), Roaming Management (S-GW устанавливает S8 Bearer с нужной PLMN если UE находится в роуминге), и т.д. (про всё это позжеее)

 c) **PDN GW – Packet Data Network Gateway** – основной узел, отвечающий за отправку пользовательских данных. P-GW выделяет IP адрес устройству, отправляет пользовательские пакеты в нужную сеть, управляет выполнением условий тарифа (максимальная скорость, объем пакета), и т.д.

 d) **PCRF и PCEF – Policy and Charging Resource/Enforcement Function** – осуществляет контроллирующую функцию выполнения тарифных планов и условий договора, отправляя правила PCC (Policy and Charging Control) на PDN GW.

 e) **HSS – Home Subscription Server** – база данных пользователей оператора. Хранит постоянные данные такие как: разрешённые сервисы для использования пользователем, разрешённые сети для подключения, ключи для шифрования, идентификаторы пользователя и т.д.

 f) **Service PDNs** – сервисы оператора, такие как IMS, либо интернет.

 g) **ePDG – evolved Packet Data Gateway** – отвечает за подключение сторонней сети, не относящейся к 3GPP. Выполняет функции соединения с PGW и AAA, шифрования данных через IPSec, а также Handover’а из сторонней сети в LTE.

 h) **AAA – Authentication and Authorizing** – выполняет функции проверки пользователя. AAA получает данные о пользователе из HSS и проверяет, имеет ли пользователь доступ к системе.
:::


## 1. LTE-Uu

LTE-Uu – радиоинтерфейс для обмена данными между UE и eNB. Отправка данных между UE и eNB организована каналами: физическими, транспортными и логическими. Пока что приведу краткое описание каждого из каналов, потом пройдемся по каждому подробнее.

Физические каналы:
1. PDCCH – Physical Downlink Control Channel – основной канал, использующийся для отправки DCI (Downlink Control Information). Функциями DCI является выделение ресурсов для UE, а также отправка TPC (Transmit Power Control) для управления мощностью антенны UE.
2. PMCH – Physical Multicast Channel – канал, использующийся для отправки MCH (Multicast Channel), который используется в MBMS (Multimedia Broadcast and Multicast Services)
3. PHICH – Physical HARQ Indicator Channel – канал, использующийся для отправки HARQ сообщений (ACK/NACK).
4. PDSCH – Physical Downlink Shared Channel – основной канал для пользовательских и управляющих данных, который поддерживает разделение ресурсов между пользователями.
5. PCFICH – Physical Control Frame Indicator Channel – канал, использующийся для отправки CFI (Control Format Indicator). CFI указывает число OFDM символов в управляющих каналах (PDCCH и PHICH).
6. PBCH – Physical Broadcast Channel – канал, использующийся только для отправки MIB (Master Information Block). MIB содержит основные параметры, нужные UE для коммуникации с сетью.
7. PUCCH – Physical Uplink Control Channel – канал, использующийся для отправки CSI (Channel Status Information), UCI (Uplink Control Information), RS (Reference Signal) и HARQ ACK/NACK. Является основным управляющим каналом в направлении uplink. Не требует постоянного выделения ресурсов, существует статически и определяется при подключении к сети.
8. PUSCH – Physical Uplink Shared Channel – основной канал в направлении uplink для отправки пользовательских и управляющих данных.
9. PRACH – Physical Random Access Channel – канал, использующийся для процедуры RACH. RACH используется при первоначальной подготовке соеденения, либо при совершении Handover’а, либо при переходе состояния UE из ECM IDLE и RRC IDLE в состояние ACTIVE. (про протокол RRC и ECM позже)

Физические каналы определяют метод модуляции и распределения символов и кадров. Однако LTE имеет возможность к изменению метода кодировки, либо других характеристик канала динамически. Для этого существует разделение на физические и транспортные каналы. Транспортные каналы определяют метод кодировки, разделение на пользователи, разбиение на транспортные блоки и т.д. Ниже приведено описание каждого из транспортных каналов:
1. DL-SCH – основной канал для отправки как пользовательских, так и управляющих сетью данных.
2. BCH – Broadcast Channel – канал, использующийся для определения кодировки MIB и его отправки на PBCH.
3. PCH – Paging Channel – канал, использующийся для отправки сообщений Paging Procedure. Paging используется для уведомлений UE о новых данных, либо других событий в сети.
4. UL-SCH – Uplink Shared Channel – основной канал для отправки пользовательских данных и сообщений управления сетью.
5. RACH – канал, использующийся для осуществения процедуры RACH.

Так как, например, по каналу DL-SCH могут отправляться данные как для всех пользователей сети, так и данные, предназначенные для одного пользователя, то необходмо далее разделить каналы по параметрам отправки. Для этого используются логические каналы.
Они определяют тип отправляемых данных, а также служат для организации DRB (Data Radio Bearer). Ниже приведено описание каждого их логических каналов:
1. MCCH/MTCH – Multicast Control/Traffic Channel – каналы для отправки управляющих данных и реальных данных соответственно. (Logical Multicast Traffic Channel, да, отсюда).
2. DCCH/DTCH – Dedicated Control/Traffic Channel – выделенный канал для отправки сообщений управления, либо для отправки пользовательских данных соответсвенно.
3. CCCH – Common Control Channel – общий канал управления, предназначенный для отправки сообщений всем UE.
4. BCCH – Broadcast Control Channel – канал для передачи основных управляющих сообщений всем UE.
5. PCCH – Paging Control Channel – канал для передачи Paging сообщений.

Для синхронизации, оценки качества канала, демодуляции сигнала, и т.д, помимо каналов данных существуют сигналы:
1. CRS – Cell specific Reference Signal – сигнал, использующийся для измерения паремтров RSRP и RSRQ, а также для MIMO (TM4).
2. DMRS – Demodulation Reference Signal – сигнал, уникальный для каждого UE, использующийся для демодуляции сигнала (TM9).
3. CSIRS – Channel State Information Reference Signal – сигнал, использующийся для оценки состояния канала (TM9).
4. PRS – Positioning Reference Signal – сигнал, использующийся eNB для определения положения UE.
5. SRS – Sounding Reference Signal – сигнал, использующийся eNB для определения качества Uplink канала для каждого устройства.
6. PSS – Primary Synchronization Signal – один из сигналов, использующийся для первичной синхронизации между eNB и UE при подключении.
7. SSS – Secondary Synchronization Signal – второй сигнал, использующийся для первичной синхронизации.


PSS и SSS используются для получения Physical Cell ID. PSS используется для получения SSS, поэтому для синхронизации и подключения к eNB требуется получить сначала PSS, затем SSS. Детали генерации сигналов будут разобраны далее.

### 1.1. Physical Channels

Каждый физический канал имеет свои уникальные характеристики:
1. Метод модуляции – каждый канал определяется методом модуляции: QAM, QPSK, BPSK
2. Размещение в Resource Grid – каждый канал имеет своё место, которое определяется параметрами частоты и временем передачи.
3. Мощность – eNB отправляет каждый канал с определённой заданной мощностью, которая, однако может меняться в рамках одного канала.
4. Precoding/Layer Mapping/Scrambling – про эти позже

#### 1.1.1. Resource Grid и Frame Structure

Для начала определимся с положением канала по времени и частоте, а также с таймингами отправки данных.

Отправка данных в LTE осуществляется по кадрам. Т.е один LTE Frame содержит в себе все данные со всех каналов. Существует два вида frame'ов: FDD и TDD. FDD – Frequency Division Duplexing, разделяет частоты пользователей и вышки, позволяя устройствам принимать и отправлять данные одновременно. TDD – Time Division Duplexing, не разделяет частоты пользователей и вышки, т.е выделяет отдельные промежутки времени для каждого пользователя на отправку и прием данных. Рассматривать будем только FDD, так как он используется чаще всего.

Рассмотрим структуру frame во времени. Следующая иллюстрация не показывает распределения символов по частоте:
```
 slot, Ts=0.5ms                               
┌─────┬─────┬─────┬────────────┬──────┬──────┐
│  0  │  1  │  2  │     ...    │  18  │  19  │
│     │     │     │            │      │      │
└─────┴─────┴─────┴────────────┴──────┴──────┘
 ◄─────────►                                  
  subframe                                    
                                              
 ◄──────────────────────────────────────────► 
                  frame, Tf=10ms              
```

Соответсвенно отсюда видно:
 1. Длительность одного frame'а – 10 мсек
 2. В каждом frame 10 subframe
 3. В каждом subframe 2 слота

Можно тогда задать вопрос: “является ли slot самым элементарным элементом отправки?”. Нет, если приблизить структуру ещё, то можно будет разбить слот на 7 меньших блоков, символов (OFDM symbol):
```
               7 OFDM Symbols            
    ◄───────────────────────────────────►
     ┌┬───┬┬───┬┬───┬┬───┬┬───┬┬───┬┬───┐
     ││ 0 ││ 1 ││ 2 ││ 3 ││ 4 ││ 5 ││ 6 │
     ││   ││   ││   ││   ││   ││   ││   │
     └┴───┴┴───┴┴───┴┴───┴┴───┴┴───┴┴───┘
          ▲  ▲                           
          │  │                           
          │  │                           
          │symbol                        
      ┌───┘                              
      │                                  
cyclic prefix                            
```

Отсюда видно, что каждый слот разбит на 7 OFDM символов, перед каждым из которых идёт Cyclic Prefix. Cyclic Prefix повторяет конец текущего символа (т.е для символа 0, Cyclic Prefix перед ним будет содержать некторое количество sample'ов из конца этого символа). Это нужно для создания интервала между символами для избежания ISI (Intersymbol Interference).

На изображении не были указаны конкретные значения длительностей элементов:
 1. Каждый первый CP слота имеет длину в 160 sample'ов (т.е 5.2 us)
 2. Каждый символ имеет длину в 2048 sample'ов (т.е 66.7 us)
 3. Остальные CP имеют длину в 144 sample'а (т.е 4.7 us)

::fs-image[Downlink RG]{path="/telco/other/images/LTEDownlinkRG.jpg" name="Downlink RG" maxWidth=800px}

Все конечно немного сложнее, так как длительности в секундах будут отличаться в зависимости от Sample Rate вышки. Обычно это 30.72 M samples/sec.

Теперь, как только мы понимаем как символы организованы во времени, надо разобраться с организацией символов по частоте.

Сигнал LTE можно представить в виде двумерной карты, где по вертикали будет частота, а по горизонтали – время. Я сделал такую иллюстрацию, где каждая клетка – это один символ. Для удобства также подписаны слоты и subframe'ы, а также цветами обозначены отдельные физические каналы:

::fs-image[Resource Grid]{path="/telco/other/images/ResourceGrid.png" name="Resource Grid" maxWidth=1200px}

Рассмотрим эту иллюстрацию подробнее:
 1. Весь сигнал LTE по частоте разбит на отдельные поднесущие, которые называются Subcarrier. Поднесущие являются основной идеей OFDM и DFT-S-OFDM, но об этом позже.
 2. Между поднесущими есть некоторое расстояние, delta phi, которое может составлять 15 KHz или 7.5 KHz (в новых спецификациях)
 3. Количество поднесущих различается в зависимости от Bandwith вышки. Например, для BW=20MHz, кол-во поднесущих $$ N_{sc}=1200 $$, а для BW=5, $$ N_{sc}=300 $$.

Мы только что рассмотрели как передача организована во времени и по частоте, теперь рассмотрим какие существуют составные элементы. 

::fs-image[Resource Grid]{path="/telco/other/images/LTEResourceUnits.jpg" name="Resource Units" maxWidth=400px}

Здесь представлена cхема объединения OFDM символов. Красным выделены Reference Signal, количество Subcarrier условное. Самый маленький элемент RG – Resource Element (RE), состоит из 1 subcarrier x 1 symbol. 4 RE объеденены в Resource Element Group по subcarrier, Reference Signal не включается в REG. Отправка PDCCH организована по Control Channel Element, который состоит из 9 REG идущих от одного края $$ N^{DL}_{RB} $$ PRB до другого, при этом меняя направление. CCE также объеденяются по колиеству в Aggregation level.

Основная единица выделения ресурсов – Physical Resource Block. PRB состоит из 84 RE: 12 subcarrier x 7 symbols (либо 72 RE при использовании Extended Cyclic Prefix). PRB объеденяются в Resource Block Group. Количество PRB в одном RBG зависит от System Bandwidth.

#### 1.1.2. Multiple Access

В этом разделе будут рассмотрены детали генерации схем Multiple Access, которые
используются в LTE. Особенности каналов учитываться не будут.

Multiple Access – это схема организации сигнала, при котором ресурсы разделяются между пользователями, как бы создавая несколько отдельных каналов для передачи данных. В LTE используются два вида Multiple Access: OFDMA и DFT-S-OFDMA (или SC-OFDMA).

##### 1.1.2.1. Orthogonal Frequency Division Multiple Access (OFDMA)

Чтобы понять, как работает OFDMA, надо сначала вспомнить его, как бы, “предшественника”, FDM, Frequency Division Multiplexing. В FDM каждому пользователю назначается своя конкретная частота, при этом частоты располагаются так, что между ними ещё остаётся пространство, называемое Guard Band. Без него частоты создавали бы интерференцию и стабильность канала была бы низкой. Так как количество частот ограничено Bandwith, то и количество отдельных каналов тоже ограничено Bandwith. И на самом деле в такой конфигурации количество каналов будет так мало, что эффективность этого метода тоже очень мала.

Исправить эту проблему помогает ортогональность. Все несущие в OFDMA располагаются ортогонально, т.е в каждый отдельный момент лишь одна несущая находится в пике, остальные в нуле. Это 
позволяет убрать GB и уместить больше каналов в Bandwith. Тут тоже у меня заготовлена иллюстрация: 

::fs-image[OFDM vs FDM]{path="/telco/other/images/LTEOFDM.jpg" name="OFDM vs FDM" maxWidth=600px}

Сверху – распределение каналов по частоте при использовании OFDM, снизу – при использовании FDM.

Ещё одним преимуществом OFDM является низкий ISI. При отправке потока на одной частоте с достаточной высокой скоростью, когда время символа Ts становится меньше чем время задержки (например из-за географических условий при отражении волны), между символами возникает Interference. OFDM делит высокоскоростной поток данных на большое количество потоков данных с низкой скоростью, тем самым избавляясь от ISI, но сохраняя скорость передачи.
```
        ┌───────────┐           ┌───────────┐                  
───────►│    S/P    │           │    P/S    ├────────►         
        │           │           │           │                  
        └─┬───┬───┬─┘           └───────────┘                  
          │   │   │               ▲   ▲   ▲                    
          ▼   ▼   ▼               │   │   │                    
        ┌───────────┐           ┌─┴───┴───┴─┐                  
        │Modulation │           │   demod   │◄──────────┐      
        │Mapping    │           │           │           │      
        └─┬───┬───┬─┘           └───────────┘           │      
          │   │   │               ▲   ▲   ▲             │      
          ▼   ▼   ▼               │   │   │             │      
        ┌───────────┐           ┌─┴───┴───┴─┐      ┌────┴─────┐
        │   IFFT    │           │    FFT    ├─────►│Channel   │
        │           │           │           │      │Estimation│
        └─┬───┬───┬─┘           └───────────┘      └──────────┘
          │   │   │               ▲   ▲   ▲                    
          ▼   ▼   ▼               │   │   │                    
        ┌───────────┐           ┌─┴───┴───┴─┐                  
        │    P/S    │           │    S/P    │                  
        │           │           │           │                  
        └─┬───┬───┬─┘           └───────────┘                  
          │   │   │                   ▲                        
          ▼   ▼   ▼                   │                        
        ┌───────────┐           ┌─────┴─────┐                  
        │  Add CP   │           │  Remove   │                  
        │           │           │    CP     │                  
        └─┬───┬───┬─┘           └───────────┘                  
          │   │   │                   ▲                        
          ▼   ▼   ▼                   │                        
        ┌───────────┐           ┌─────┴─────┐                  
        │ Passband  │xxxxxxxxxxx│ Passband  │                  
        │ Generation│xxxxxxxxxxx│   demod   │                  
        └───────────┘    ▲      └───────────┘                  
                         │                                     
                         │                                     
                 radio transmission                            
```

На рисунке предствалена схема генарации OFDM сигнала. В основе генерации лежит распределение данных на некоторое количество поднесущих (Subcarriers). Некоторые из них предназначены для передачи данных (Data Subcarriers), а некоторые для передачи константного значения, которое используется для Channel Estimation (Pilot Subcarriers). Рассмотрим процедуру генерации OFDM сигнала для 16QAM (µ = 4).

1. S/P – Serial To Parallel – этап разделения потока на отдельные символы для последующей модуляции. Имея набор бит $$ x = [x_0, x_1, \dots, x_{n-1}] $$ необходимо получить матрицу
$$
X = \begin{pmatrix}
    x_0     & x_1         & \dots  & x_{\mu - 1}  \\ 
    x_{\mu} & x_{\mu + 1} & \dots  & x_{2\mu - 1} \\
    \vdots  & \vdots      & \ddots & \vdots       \\
    x_{(N^D_{subc} - 1)\mu} & x_{(N^D_{subc} - 1)\mu + 1} & \dots & x_{N^D_{subc}\mu - 1}
\end{pmatrix}
$$
:::margin{ml=28}
 Где каждая строка – отдельный набор бит, который можно представить в виде QAM символа. Соответственно, количество строк будет совпадать с количеством Data Subcarriers $$ N^D_{subc} $$.
:::

2. Modulation Mapping – этап модуляции полученных бит. Имея набор бит $$ X $$ для каждой поднесущей, производится соотношение набора бит с таблицей модуляции. Соответственно, каждый символ превращается в набор комлексных чисел $$ m = [m_0, m_1, \dots, m_{i - 1}] $$, где $$ i $$ – количество модулируемых символов ($$ N^D_{subc} $$)

3. Subcarrier and Pilot Carrier Allocation – на этом этапе на каждую поднесущую размещается один QAM символ, или константное значение $$ P_v $$ (на Pilot Subcarrier).
$$
S[k] = \begin{cases}
 m[k] & \text{если } k \in \text{ data subcarriers} \\
 P_v & \text{если } k \in \text{ pilot subcarriers} \\
\end{cases}
$$

4. IFFT – Inverse Fast Fourier Transform – к полученному массиву применяется IFFT для генерации ортогонального сигнала. 
$$
F[l] = \frac{1}{N_{subc}}\sum^{N_{subc} - 1}_{k = 0}{S[k]e^{j2\pi kl N^{-1}_{subc} }}
$$

5. Add Cyclic Prefix – для того, чтобы избавиться от ISI, необходимо добавить Cyclic Prefix. CP – это копия конца символа, которую добавляют в начало. $$ C[n] = [F[N_{subc} - N_{cp},\dots,F[N_{subc} - 1],F[0], F[1], \dots, F[N_{subc} - 1]]] $$ где $$ N_{cp} $$ – количество символов для копирования.

6. Passband generation – т.к полученный результат является массивом комлексных
чисел, то необходимо получить сигнал, который будет состоять только из чисел, без
комплексной части: $$ P[t] = Re{(C[t])} \cos{(2\pi f_c t)} - Im{(C[t])} \sin{(2\pi f_c t)} $$


В спецификации LTE определены два типа CP: Normal CP и Extended CP. В таблице приведены значения $$ N_{cp} $$ для каждого типа CP и $$ \Delta f $$:
| Configuration   | $$\Delta f = 15\ \text{kHz}$$                | $$160\ (k = 0)$$           |
|-----------------|----------------------------------------------|----------------------------|
| Normal CP       | $$\Delta f = 15\ \text{kHz}$$                | $$160\ (k = 0)$$           |
|                 |                                              | $$144\ (k \in \{1, \dots, 6\})$$ |
| Extended CP     | $$\Delta f = 15\ \text{kHz}$$                | $$512$$                    |
|                 | $$\Delta f = 7.5\ \text{kHz}$$               | $$1024$$                   |
|                 | $$\Delta f = 1.25\ \text{kHz}$$              | $$6144$$                   |



Вам может быть проще понять генерацию смотря на код, а не на математику. Поэтому:
```python
import numpy as np
import matplotlib.pyplot as plt
import math
import modulation

n_subc = 64
cp = int(n_subc * 0.25)
n_pilot = 8
pilot_value = 1
carrier_freq = 10000000
sampling_rate = 20000000
t_samp = 1 / sampling_rate

data_carriers_len = n_subc - n_pilot
bits_per_carrier = modulation.mu * data_carriers_len

# generates indices of all subcarriers from 0 to n_subc - 1
carriers = np.arange(n_subc)

# only the pilot carriers
# so we take each n_subc//n_pilot subcarrier
pilot_carriers = carriers[::n_subc//n_pilot]

# deleting all pilot carriers to get
# only the data carriers
data_carriers = np.delete(carriers, pilot_carriers)

bits = np.random.binomial(n=1, p=0.5, size=(bits_per_carrier))

# reshaping an array of bytes to send a QAM symbol on 
# each subcarrier
sp = bits.reshape((data_carriers_len, modulation.mu))
mapped = np.array([modulation.qam_table[tuple(b)] for b in sp])

symbol = np.zeros(n_subc, dtype=complex)
symbol[pilot_carriers] = pilot_value
symbol[data_carriers] = mapped

symbol_time = np.fft.ifft(symbol)
cp_sym = symbol_time[-cp:]
symbol_cp = np.hstack([cp_sym, symbol_time])

# Upconversion taken from 36.211 15.2.0 6.13 (p. 180) (figure 6.13-1)
real_symbol = [np.real(symbol_cp[idx]) * math.cos(2 * math.pi * carrier_freq * idx * t_samp) -
               np.imag(symbol_cp[idx]) * math.sin(2 * math.pi * carrier_freq * idx * t_samp)
               for idx in range(len(symbol_cp))]
```

О модуляции поговорим чуть позже, хотя в коде она тут уже есть.

##### 1.1.2.2. Single Carrier Frequency Division Multiple Access (SC-FDMA)

SC-FDMA использует похожую схему генерации сигнала как и в OFDM, однако в
процедуру добавляется дополнительный этап выполнения DFT. Такой процесс называется DFT-S-OFDM (Discrete Fourier Transform Spread OFDM). Первым шагом является модуляция, затем над массивом QAM символов выполняется операция DFT, растягивая каждый символ по всем Subcarrier’ам. Такой алгоритм выполняется для всех Uplink каналов, за исключением PRACH (и PUSCH при использовании sub-PRB метода выделения ресурсов).

Как и для OFDMA, значения Ncp также зависят от типа CP:
| Configuration | $$N_{cp}(k)$$                      |
|---------------|------------------------------------|
| Normal CP     | $$160\ (k = 0)$$                    |
|               | $$144\ (k \in \{1, \dots, 6\})$$    |
| Extended CP   | $$512$$                             |


#### 1.1.3. Modulation

В этом разделе будут рассмотрены методы модуляции, которые используются в LTE.

Модуляция – это грубо говоря процесс преобразования наборов сырых данных в данные на отправку по радио. Например, допустим мы имеем набор бит $$ b = [0, 1, 1, 0, 0, 1, 1, 0] $$ – т.е один байт. Каким образом мы можем передать этот набор бит?

 1. Можно например назначить единице частоту F1, а нулю частоту F0. Далее определить тайминг отправки, например каждый символ будет отправляться 1 мсек. И далее мы будем отправлять этот байт таким образом: сначала на частоте F0 ровно 1 мсек будет сигнал, потом на частоте F1, потом снова на F1, потом на F0 и так далее. Таким образом, мы отправляем один и тот же сигнал, просто на разных частотах и передаём данные. Такой метод называется FSK, Frequency-Shift Keying. Мы рассмотрели его самый простой вариант: BFSK, Binary FSK, потому что у нас есть всего две частоты.
 Мы же можем назначить свою частоту какому-нибудь набору бит, например 00 – F0, 01 – F1, 10 – F2, 11 – F3. В таком случае мы уже будем отправлять данные быстрее в два раза, так как за раз отправляем не один бит, а два. Такой метод называется 4-FSK.


Какие ещё параметры сигнала мы можем менять чтобы отправлять данные? Тратить так много частоты не хочется, хочется как-то по-другому закодировать набор бит.

 2. Тогда хорошо, давайте попробуем управлять амплитудой. Допустим для 0 назначим свою амплитуду A0, а для единицы – A1. Теперь, мы будем на одной и той же частоте просто менять амплитуду сигнала когда хотим отправить какие-нибудь данные. А ещё ведь можно для набора бит обозначить амплитуду, вообще получается топ метод. Но нет. В силу уже вступают практические ограничения. Как и в случае с AM (Amplitude Modulation), метод ASK (Amplitude Shift Keying), очень сильно подвержен атмосферному шуму, различным искажениям сигнала, и так далее. Такой метод достаточно хорош если у нас нет стороннего шума, например как в ОПТОВОЛОКНЕ, но мы работаем с радио и позволить такое не можем.


Хорошо, тогда попробуем ещё что-нибудь

 3. Почему бы не менять фазу? Отличная идея, давайте будем менять смещение сигнала в зависимости от бита, которого мы отправляем. Вот тут хорошо изображено как это работает: (Phase Shift Keying) https://imgur.com/a/4FquDey. Это уже действительно хороший метод. На практике он довольно стабильный и даже используется в RFID и Bluetooth. Насколько вы знаете, однако, Bluetooth не очень быстрый... Да, такой метод модуляции будет хорошо работать если мы используем всего два, ну максимум 4 бита для одного символа, поэтому скорость передачи будет не очень большой.


Тогда... почему бы не совместить какие нибудь методы и получить более хороший метод модуляции?

 4. QAM – Quadrature Amplitude Modulation – тот самый метод, который используется и в LTE, и в 5G NR и ещё много где. Идея в чем: вместо того, чтобы работать с сигналом напрямую, лучше сделать некую абстракцию с двумя параметрами, которые мы можем менять чтобы создавать новый сигнал, который будет и смодулирован и достаточно устойчив. Такая абстракция называется I/Q: In-Phase and Quadrature Data. IQ сигнал создаётся с помощью сложения двух ортогональных волновых функций: самые простые – синус и косинус. Если вы внимательно читали раздел про OFDM, то можете вспомнить этап Passband Generation. Там как раз происходит генерация IQ сигнала, т.е Upconversion: $$ Icos(2*pi*fc*t) - Qsin(2*pi*fc*t) $$.
Что это даёт? Теперь мы работаем не с сигналом напрямую, то есть не с частотой, смещением и амплитудой, а с двумя абстрактными параметрами I и Q. Различным комбинациям этих параметров можно назначить своё значение комбинации битов. В LTE так и просходит. Обратимся к спецификации 3GPP TS 36.211 15.2.0, таблица 7.1.3-1: 16 QAM modulation mapping:

| Bits  | $$I$$           | $$Q$$           |
|-------|-----------------|-----------------|
| 0000  | $$+1/\sqrt{10}$$ | $$+1/\sqrt{10}$$ |
| 0001  | $$+1/\sqrt{10}$$ | $$+3/\sqrt{10}$$ |
| 0010  | $$+3/\sqrt{10}$$ | $$+1/\sqrt{10}$$ |
| 0011  | $$+3/\sqrt{10}$$ | $$+3/\sqrt{10}$$ |
| 0100  | $$+1/\sqrt{10}$$ | $$-1/\sqrt{10}$$ |
| 0101  | $$+1/\sqrt{10}$$ | $$-3/\sqrt{10}$$ |
| 0110  | $$+3/\sqrt{10}$$ | $$-1/\sqrt{10}$$ |
| 0111  | $$+3/\sqrt{10}$$ | $$-3/\sqrt{10}$$ |
| 1000  | $$-1/\sqrt{10}$$ | $$+1/\sqrt{10}$$ |
| 1001  | $$-1/\sqrt{10}$$ | $$+3/\sqrt{10}$$ |
| 1010  | $$-3/\sqrt{10}$$ | $$+1/\sqrt{10}$$ |
| 1011  | $$-3/\sqrt{10}$$ | $$+3/\sqrt{10}$$ |
| 1100  | $$-1/\sqrt{10}$$ | $$-1/\sqrt{10}$$ |
| 1101  | $$-1/\sqrt{10}$$ | $$-3/\sqrt{10}$$ |
| 1110  | $$-3/\sqrt{10}$$ | $$-1/\sqrt{10}$$ |
| 1111  | $$-3/\sqrt{10}$$ | $$-3/\sqrt{10}$$ |


 Такой метод модуляции уже позволяет отправлять аж 4 бита за раз. Можно ведь здесь не останавливаться и отправлять больше. LTE поддерживает 1024QAM, в котором можно отправить целых 10 бит за раз (раздел 7.1.6).

Кому проще смотреть на код:
```python
import math
import matplotlib.pyplot as plt
import numpy as np

mu = 4

# taken from 36.211, table 7.1.3-1 (16 QAM modulation mapping)
# https://www.etsi.org/deliver/etsi_ts/136200_136299/136211/15.02.00_60/ts_136211v150200p.pdf
qam_table = {
    (0, 0, 0, 0): complex(1/math.sqrt(10), 1/math.sqrt(10)),
    (0, 0, 0, 1): complex(1/math.sqrt(10), 3/math.sqrt(10)),
    (0, 0, 1, 0): complex(3/math.sqrt(10), 1/math.sqrt(10)),
    (0, 0, 1, 1): complex(3/math.sqrt(10), 3/math.sqrt(10))
}

# from the same table, when the first bit is 1, the real 
# part of the complex number is negated
# when the second bit is 1, the imaginary part is negated
# here, we just generate the table
for i in range(4, 16):
    bits = tuple([int(n) for n in list(np.binary_repr(i).rjust(4, "0"))])
    iq_mapped = qam_table[(0, 0, bits[2], bits[3])]
    i = iq_mapped.real
    q = iq_mapped.imag

    if bits[0] == 1:
        i = -i
    if bits[1] == 1:
        q = -q
    
    qam_table[bits] = complex(i, q)
```

Этот код сгенерирует распределение параметров IQ. Визуально станет ясно почему были выбраны именно такие значения, с виду рандомные: (16QAM Modulation) https://imgur.com/a/4FquDey. Да, они расположены в таком прямоугольном паттерне. Это справедливо для каждого из видов QAM (16, 256, 1024 QAM).

Тут можно задать вопрос: “а почему точки распологаются именно в таком квадратном виде? не лучше было бы подобрать такую фигуру, при котором расстояние было бы максимальным, соответсвенно увеличивалась бы стабильность передачи?”. Это справедливый вопрос. И да, другие паттерны тоже есть, например Cross-QAM. Cross-QAM может помочь достичь большей эффективности, но используется редко из-за сложностей в реализации оборудования для демодуляции такого сигнала.

#### 1.1.4. MIMO

Мы разобрались ещё с одним понятием из физического уровня LTE, теперь перейдём к следующему: MIMO, Mulitple In, Multiple Out.

Очень грубо говоря и сильно упрощая, MIMO – техника, которая позволяет отправить больше данных без использование дополнительных радио ресурсов. Т.е для отправки большего количества данных нам не понадобится выделять ещё частоты или тратить больше времени. Нужно только больше антенн.

Существует два подхода к реализации MIMO: SU-MIMO (Single User MIMO) и MU-MIMO (Multi-User MIMO). SU-MIMO фокусируется на обслуживании одного пользователя,
тогда как MU-MIMO обслуживает сразу несколько пользователей, подстраиваясь под изменяющиеся условия выделенных ресурсов.

Я сделал очень упрощённую иллюстрацию работы MIMO: (MIMO Model) https://imgur.com/a/4FquDey.

Из неё видно:
 1. На передатчике есть две антенны, которые передают два разных потока, x1 и x2.
 2. Сигнал с каждой из передающих антенн принимается на каждой антенне принимающей стороны. Например, сигнал с первой антенны передатчика принимается на первой и на второй антенне приёмника.
 3. Принимающая сторона декодирует два потока и получает данные в оригинальном виде.

h11, h12, h21 и h22 – это коэффициенты, показывающие какое количество данных идёт по конкретному пути. Чем больше число, тем больше данных проходит по пути. Из этих коэффициентов можно сделать матрицу, она называется Channel Information Matrix. Соответсвенно математически мы можем смоделировать канал так: $$ y = Hx $$: (MIMO Channel Information Matrix) https://imgur.com/a/ptgfM4Z

Теперь, как мы можем из этого восстановить оригинальный сигнал? Тут думаю логично: $$ x = H^{-1} * y $$. Нужно взять обратное от матрицы канала и умножить на полученный сигнал $$ y $$. Но с таким подходом есть проблемы: во первых он подразумевает, что на принимающей стороне полностью известна матрица канала, а это чаще всего не так (она изменяется часто и её получение - затратный процесс). Даже если матрица канала была бы известна, такой метод работал бы все равно плохо, так как на практике он даёт плохие результаты при наличии рандомного шума, который в коммуникационных системах всегда есть.

Существует ещё несколько вариантов как можно получить оригинальный сигнал:

 1. ZF - Zero Forcing - $$ x = ((H^H*H)^{-1} * H^H) * y $$ (тут операция ^H - Эрмитово сопряжение (Hermitian Transpose)). Если вы немного знакомы с линалгом, то могли уже заметить, что на самом деле формула - это Moore-Penrose pseudoinverse (псевдообратная матрица Мура-Пенроуза). Такой метод позволяет лучше обрабатывать наличие ISI, однако при наличии шума при коммуникации он может его усиливать, ухудшая качество канала. И да, этот метод также предполагает, что нам полностью известна матрица канала.

В общем тут уже должно быть ясно, что стоит искать метод, который бы как-нибудь не использовал Channel Information Matrix ($$ H $$). И такой метод есть:

 2. SVD - Signle Value Decomposition - давайте сначала рассмотрим обычную процедуру SVD, потому уже перейдём к тому, как это реализовано в LTE. 
 В общем, я не буду вдаваться в объяснение самого SVD с точки зрения математики, как нибудь потом уже отдельно об этом напишу, там очень интересно. Сейчас что важно понять: SVD разбивает матрицу "H" на три матрицы: $$ U $$, $$ S $$ и $$ V^H $$. Идея в том, чтобы представить матрицу канала в виде какой-нибудь простой диагональной матрицы, в которой получить коэфициенты будет легко. Опять же, давайте взглянем на матрицу канала: $$ H = U*S*V^H $$. Именно $$ S $$ и является такой матрицей, но как убрать остальные множители? Тут мы можем сделать такую схему: (MIMO SVD Procedure) https://imgur.com/a/ptgfM4Z. Отправитель имеет свою матрицу, Precoding Matrix. Она получается путем применения Hermitian Transpose к полученной с помощью SVD матрице $$ V^H $$. У принимающей стороны тоже есть своя матрица, Receiver Matrix, она тоже получается из SVD. В итоге после применения обоих матриц, канальной матрицей становится $$ S $$, которая по свойству SVD является диагональной. Таким образом мы получаем ровно два коэфициента, т.е только два потока. Получить и удалить эти коэфициенты очень легко, для этого существуют LTE Signals. Общая схема применения матриц перед вами.

```
         ┌─────┐    σ1    ┌──────┐        
   x₀    │     ├─────────►│      │   y₀   
────────►│     │          │      ├───────►
         │  V  │          │  Uᴴ  │        
   x₁    │     │          │      │   y₁   
────────►│     │    σ2    │      ├───────►
         │     ├─────────►│      │        
         └─────┘          └──────┘        
```

Опять же, кому проще смотреть на код:
```python
import numpy as np

n_stream = 4
tx_ant = 4
rx_ant = 2

s = (np.random.rand(n_stream) + 1j * np.random.rand(n_stream)).reshape(n_stream, 1)
H = (np.random.randn(rx_ant, tx_ant) + 1j*np.random.randn(rx_ant, tx_ant)) / np.sqrt(2)

print(s)

U, Sigma, Vh = np.linalg.svd(H)
V = np.matrix(Vh).H
Uh = np.matrix(U).H

Sigma_diag = np.diag(Sigma)

x = V @ s 
y = Uh @ (H @ x)
recovered = np.linalg.inv(Sigma_diag) @ y

print(recovered)
```

Тут s - это сигнал на отправку (матрица сразу с 4 потоками), а recovered - сигнал полученный после передачи используя MIMO. Эти две переменные полностью совпадают.

Тут можно спросить: "так нам же всё равно надо знать канальную матрицу чтобы получить $$ V $$ и $$ U^H $$, разве нет?". Да, это так. Но главный плюс метода с Precoding матрицей заключается в том, что мы можем заранее просчитать обе матрицы и потом просто выбирать их при соответсвующих условиях канала. Именно так в LTE и в 5g NR сделали. Такие таблицы матриц называются Codebook. Они являются основным преимуществом 5g NR над LTE, так как именно эту часть в 5g NR и переделывали (и да, это также и основное различие между 5g NR и LTE).

##### 1.1.4.1. Precoding

В этом разделе рассмотрим таблицы матриц которые используются для осуществления этапа Precoding в MIMO.

Обратимся к документации: 

(3GPP TS 36.213 15.2.0, таблица 7.1-5, PDCCH and PDSCH configured by C-RNTI)
<table>
  <tr>
    <th>Mode</th>
    <th>DCI Format</th>
    <th>PDSCH Transmission</th>
  </tr>
  <tr>
    <td>Mode 1</td>
    <td>1A, 1, 7-1A</td>
    <td>Single-antenna port, port 0 (see 7.1.1)</td>
  </tr>
  <tr>
    <td>Mode 2</td>
    <td>1A, 1, 7-1A</td>
    <td>Transmit diversity (see 7.1.2)</td>
  </tr>
  <tr>
    <td>Mode 3</td>
    <td>1A, 2A, 7-1B</td>
    <td>Transmit diversity (7.1.2) or<br>Large delay CDD (7.1.3)</td>
  </tr>
  <tr>
    <td>Mode 4</td>
    <td>1A, 2, 7-1C</td>
    <td>Transmit diversity (7.1.2) or<br>Closed-loop spatial multiplexing (7.1.4)</td>
  </tr>
  <tr>
    <td rowspan="2">Mode 5</td>
    <td>1A</td>
    <td>Transmit diversity (7.1.2)</td>
  </tr>
  <tr>
    <td>1D</td>
    <td>Multi-user MIMO (7.1.5)</td>
  </tr>
  <tr>
    <td rowspan="2">Mode 6</td>
    <td>1B, 1A</td>
    <td>CL spatial multiplexing (7.1.4), single layer, or Transmit Diversity</td>
  </tr>
  <tr>
    <td>7-1D</td>
    <td>CL spatial multiplexing (7.1.4) or Transmit diversity (7.1.2)</td>
  </tr>
  <tr>
    <td>Mode 7</td>
    <td>1A, 1</td>
    <td>Port 0 (if 1 PBCH port), else Transmit diversity (7.1.2); Port 5 (see 7.1.1)</td>
  </tr>
  <tr>
    <td>Mode 8</td>
    <td>2B, 7-1E, 1A</td>
    <td>Dual-layer (7,8), single port 7/8, or Transmit diversity (7.1.2); MBSFN: port 7</td>
  </tr>
  <tr>
    <td>Mode 9</td>
    <td>2C, 1A</td>
    <td>Dual-layer (7-8), up to 8-layer (7-14) or port 7,8,11,13 (7.1.1)</td>
  </tr>
</table>


Тут упоминается RNTI и DCI, при них поговорим позже. Просто пока скажу: с помощью DCI производится выделение ресурсов, в нем отправляется информация о методе передачи данных, Transmission Mode, и т.д. А RNTI - это условно id устройства. Их есть несколько типов и каждый работает по-своему, но в это мы углубимся позже, когда уже будем проходить MAC.

Так вот. Эта таблица указывает какие методы Precoding должны использоваться в зависимости от текущего Transmission Mode, TM. TM я уже упоминал во введении.

 1. Рассмотрим Precoding для Transmit Diversity (TM2, TM3, TM5, TM6, TM7, TM8). Сначала рассмотрим общую процедуру:

```
                  ┌───────────┐port 0 ┌─────────┐
┌─────────┐       │           ├──────►│RE Mapper│
│         │x00,x0i│           │y00,y0i│         │
│  Layer  ├──────►│ Precoding │       └─────────┘
│  Mapper │       │           │port 1 ┌─────────┐
│         │       │           ├──────►│RE Mapper│
└─────────┘       │           │y10,y1i│         │
                  └───────────┘       └─────────┘
```
 Из документации 7.1.2: генерация сигнала осуществляется в соотвествии с 36.211 6.3.4.3. В случае с двумя антеннами распределение входных символов будет производиться следующим образом:

$$
\begin{vmatrix}
 y^{(0)}(2i) \\
 y^{(1)}(2i) \\
 y^{(0)}(2i + 1) \\
 y^{(1)}(2i + 1) \\
\end{vmatrix} = \frac{1}{\sqrt{2}} \begin{vmatrix}
 1 & 0 & j & 0 \\
 0 & -1 & 0 & j \\
 0 & 1 & 0 & j \\
 1 & 0 & -j & 0
\end{vmatrix} \begin{vmatrix}
 \text{Re}(x^{(0)}(i)) \\
 \text{Re}(x^{(1)}(i)) \\
 \text{Im}(x^{(0)}(i)) \\
 \text{Im}(x^{(1)}(i)) \\
\end{vmatrix} 
$$

 Или в коде:

```python
import numpy as np

M_layer_symb = 8
x = (np.random.rand(M_layer_symb*2) + 1j * np.random.rand(M_layer_symb*2)).reshape(2, M_layer_symb)
precoding = (1 / np.sqrt(2)) * np.array([
    [1,  0,  1j,   0],
    [0, -1,  0,   1j],
    [0,  1,  0,   1j],
    [1,  0,  -1j,  0]
])
y = np.zeros((2, 2 * M_layer_symb), dtype=complex)

for i in range(M_layer_symb):
    precoded = precoding @ np.array([
        x[0][i].real,
        x[1][i].real,
        x[0][i].imag,
        x[1][i].imag
    ])
    y[0, 2*i]     = precoded[0]
    y[1, 2*i]     = precoded[1]
    y[0, 2*i + 1] = precoded[2]
    y[1, 2*i + 1] = precoded[3]

print(y)
```

 Если нарисовать Constellation диаграмму, то увидим следующее: (MIMO Precoding Transmit Diversity Constellation) https://imgur.com/a/ptgfM4Z. Видно, что символы распределились таким образом, что антенна 0 вещает только в первой четверти, а антенна 1 только во второй и четвертой. Также можно заметить некоторую симметрию точек. Чем ближе они находятся к 0 координат, тем больше симметричных точек. Это обеспечивает бОльшую вероятность успешного декодирования сигнала, так как чем ближе находятся точки, тем сложнее декодировать символы.

 2. Precoding with Large Delay CDD - чтобы разобраться с этим методом Precoding, надо сначала понять что такое CDD. CDD - Cyclic Delay Diversity - это такой вид передачи данных, при котором к кажому OFDM Subcarrier'у применяется Phase Delay, то есть смещение по фазе. Это используется для увеличения разницы в распростронении сигнала между двумя путями, то есть для упрощения декодирования сигнала. Грубо говоря, в CDD одна антенна вещает оригинальный сигнал, когда как вторая вещает сигнал с небольшой циклической задержкой (т.е сигнал смещается по фазе и конец символа копируется в начало сразу после Cyclic Prefix). CDD применяется только в TM3 и для него существует свой вид Precoding.
 Опять обратимся к спецификации. В разделе 7.1.3, 36.213, Large Delay CDD scheme описано, что Precoding должен осуществляться в соотвествии с 36.211 6.3.4.2.2. Видим общую формулу Precoding'а: (MIMO Precoding Large CDD Schema) https://imgur.com/a/ptgfM4Z:

$$
\begin{vmatrix}
 y^{(0)}(i) \\
 \vdots \\
 y^{(P - 1)}(i) \\
\end{vmatrix} = W(i)D(i)U \begin{vmatrix}
 x^{(0)}(i) \\
 \vdots \\
 x^{(v - 1)}(i) \\
\end{vmatrix}
$$
 
 Тут: $$ W(i) $$ - матрица используемая для распределения сигнала между каждой физической антенной, $$ D(i) $$ - матрица, используемая для применения Phase Shift, $$ U $$ - матрица, распределяющая мощность между каждой физической антенной.
 $$ D(i) $$ и $$ U $$ описаны в таблице 36.211 6.3.4.2.2-1: Large-delay cyclic delay diversity и зависят от количества уровней (т.е количества потоков в результате Layer Mapper): (MIMO Precoding Large CDD D(i) and U) https://imgur.com/a/ptgfM4Z.
 При этом $$ W(i) $$ выбирается из общей таблицы 6.3.4.2.3-1, при этом в случае с двумя антеннами используется матрица номер 0. Здесь полная процедура, где собрана вся информация о всех матрицах: (MIMO Precoding Large CDD Full Procedure) https://imgur.com/a/ptgfM4Z.

И теперь опять же, реализация в коде:

```python
import numpy as np
import matplotlib.pyplot as plt
from modulation import qam_table

U_matrices = {
    2: (1 / np.sqrt(2)) * np.array([
        [1,          1         ],
        [1, np.exp(-1j * np.pi)]
    ]),
    3: (1 / np.sqrt(3)) * np.array([
        [1, 1, 1],
        [1, np.exp(-1j * 2 * np.pi / 3), np.exp(-1j * 4 * np.pi / 3)],
        [1, np.exp(-1j * 4 * np.pi / 3), np.exp(-1j * 8 * np.pi / 3)],
    ]),
    4: (1 / 2) * np.array([
        [1, 1, 1, 1],
        [1, np.exp(-1j * 2 * np.pi / 4), np.exp(-1j * 4 * np.pi / 4), np.exp(-1j * 6 * np.pi / 4)],
        [1, np.exp(-1j * 4 * np.pi / 4), np.exp(-1j * 8 * np.pi / 4), np.exp(-1j * 12 * np.pi / 4)],
        [1, np.exp(-1j * 6 * np.pi / 4), np.exp(-1j * 12 * np.pi / 4), np.exp(-1j * 18 * np.pi / 4)],
    ])
}

D_matrices = {
    2: np.array([
        [1, 0],
        [0, np.exp(-1j * 2 * np.pi / 2)]
    ]),
    3: np.array([
        [1, 0, 0],
        [0, np.exp(-1j * 2 * np.pi / 3), 0],
        [0, 0, np.exp(-1j * 4 * np.pi / 3)],
    ]),
    4: np.array([
        [1, 0, 0, 0],
        [0, np.exp(-1j * 2 * np.pi / 4), 0, 0],
        [0, 0, np.exp(-1j * 4 * np.pi / 4), 0],
        [0, 0, 0, np.exp(-1j * 6 * np.pi / 4)],
    ])
}

codebook_1 = [
    {
        1: (1 / np.sqrt(2)) * np.array([[1], [1]]),
        2: (1 / np.sqrt(2)) * np.array([
            [1, 0],
            [0, 1]
        ])
    },
    {
        1: (1 / np.sqrt(2)) * np.array([[1], [-1]]),
        2: (1 / np.sqrt(2)) * np.array([
            [1, 1],
            [1, -1]
        ])
    },
    {
        1: (1 / np.sqrt(2)) * np.array([[1], [1j]]),
        2: (1 / np.sqrt(2)) * np.array([
            [1, 1],
            [1j, -1j]
        ])
    },
    {
        1: (1 / np.sqrt(2)) * np.array([[1], [-1j]]),
    }
]

M_layer_symb = 64
v = 2
P = 2

num_bits = v * M_layer_symb * 4  
bitstream = np.random.randint(0, 2, num_bits)
symbols = []
for i in range(0, len(bitstream), 4):
    bits = tuple(bitstream[i:i+4])
    symbols.append(qam_table[bits])

x = np.array(symbols).reshape(v, M_layer_symb)

W = codebook_1[0][v] 
D = D_matrices[v]
U = U_matrices[v]

y = W @ D @ U @ x

print(y)
```

 Если нарисовать график, то можно увидеть следующее: (MIMO Precoding Large CDD Constellation) https://imgur.com/a/ptgfM4Z. Каждый символ распределился по двум антеннам. Фазовый угол (phase difference) одного уровня (с Layer Mapper) между сигналом на антеннах равен 180 или 0 в зависимости от i (т.е половина символов будет иметь разницу 180 градусов, другая половина - в 0).

 3. Теперь разберемся со Spatial Multiplexing. Базовая формула простая и уже нам знакомая:

$$
\begin{vmatrix}
 y^{(0)}(i) \\
 \vdots \\
 y^{(P - 1)}(i) \\
\end{vmatrix} = W(i) \begin{vmatrix}
 x^{(0)}(i) \\
 \vdots \\
 x^{(v - 1)}(i) \\
\end{vmatrix}
$$

 При этом в случае с двумя антеннами используется та же таблица, что и для Large Delay CDD: 6.3.4.2.3-1. Выбор индекса в таблице осуществляется на базовой станции и передаётся на UE в DCI format 2 в поле PrecodingInformation. 
 Всё меняется при использовании 4 антенн. В этом случае используется другая таблица: 6.3.4.2.3-2. В ней напрямую не указаны матрицы для использования, нужно пройти через несколько этапов прежде чем можно будет их получить. Для начала нужно знать как генерируется $$ W_n $$. Это делается по формуле, представленной в 6.3.4.2.3. Выбранное значение u0 посдатвляется в формулу $$ W_n $$ и вычисляется $$ W_n $$. Затем в определённом порядке выбираются столбцы, указанные в таблице 6.3.4.2.3-2 и соотвественно определяется сама матрица W. Я сделал полную иллюстрацию здесь: (MIMO Precoding 4 Antenna Case) https://imgur.com/a/ptgfM4Z. На ней указаны все шаги генерации 4х матриц для codebook index 0.

---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

#### 1.1.5. Physical Downlink Channels

(В прошлый раз мы разобрались с базовыми концепциями в физическом уровне LTE. В этом посте мы вместе разберем уже особенности каждого физического канала по отдельности, а также объеденим все изученные прежде концепции воедино.)

Здесь сейчас будет много математики. По оформлению скажу: буду в тексте приводить формулы в виде latex. В изображениях они будут в срендеренном виде и с моими обозначениями, там смотреть гораздо удобнее и понятнее.

Для начала давайте рассмотрим общую процедуру генерации сигнала, она будет переиспользоваться для всех остальных каналов:

```
codewords                                               
    │         User Data                                 
    └────────────►│b[q](0),b[q](1),...,b[q](M[q](bit)-1)
                  ▼                                     
      ┌────────────────────────┐                        
      │       Scrambling       │                        
      │      36.211 6.3.1      │                        
      └───────────┬────────────┘                        
                  │B[q](0),...,B[q](M[q](bit)-1)        
                  ▼                                     
      ┌────────────────────────┐                        
      │    Modulation Mapper   │                        
      │      36.211 6.3.2      │                        
      └───────────┬────────────┘                        
                  │d[q](0),...,d[q](M[q](symb)-1)       
                  ▼                                     
      ┌────────────────────────┐                        
      │      Layer Mapper      │                        
      │      36.211 6.3.3      │                        
      └───────────┬────────────┘                        
                  │[x[0](i),...,x[v-1](i)]^T            
                  ▼                                     
      ┌────────────────────────┐                        
      │        Precoding       │                        
      │      36.211 6.3.4      │                        
      └───────────┬────────────┘                        
                  │[y[0](i),...,y[P-1](i)]^T            
                  │                                     
                  ▼                                     
      ┌────────────────────────┐                        
      │Resource Element Mapper │                        
      │      36.211 6.3.5      │                        
      └───────────┬────────────┘                        
                  │s[p](l)(t)                           
                  ▼                                     
      ┌────────────────────────┐                        
      │ OFDM Signal Generation │                        
      │      36.211 6.12       │                        
      └────────────────────────┘                        
```

##### 1.1.5.1. Scrambling

Scrambling - процесс добавления к сырым битам данных известного UE значения. Рассмотрим математику этого этапа: (PHY Scrambling) https://imgur.com/a/ptgfM4Z.

Для начала генерируется начальный параметр "c": $$ c_{init} = n_{RNTI} \cdot 2^{14} + q \cdot 2^{13} + \lfloor \frac{n_s}{2} \rfloor \cdot 2^9 + N^{cell}_{ID} $$, где $$ n_{RNTI} $$ - RNTI, присвоенный текущей PDSCH передаче, $$ N^{cell}_{ID} $$ - Cell Identity (физический ID вышки), $$ n_s $$ - номер текущего слота. О RNTI и Cell ID будем говорить позже, сейчас просто стоит принять, что они здесь используются.

Этот начальный параметр используется для генерации `c(n)`: 
$$
c(n) = (x_1(n + N_c) + x_2(n+N_c)) \mod 2 \\
x_1(n + 31) = (x_1(n+3) + x_1(n)) \mod 2 \\
x_2(n + 31) = (x_2(n+3) + x_2(n+2) + x_2(n+1) + x_2(n)) \mod 2
$$

При этом x_1 инициализируется следующим образом: $$ x_1(0) = 1, \ x_1(n) = 0, \ n = 1,2,\dots,30 $$, а $$ x_2 $$ как раз и использует $$ c_{init} $$: $$ c_{init} = \sum_{i=0}^{30}{x_2(i) \cdot 2^i} $$. Такая нотация для $$ x_2 $$ довольно сложная, но посути она говорит о том, что берется каждый бит значения $$ c_{init} $$ и назначается к начальному массиву $$ x_2 $$. Например для $$ c_{init}=9 $$ (0b1001), $$ x_2 $$ инициализируется как [0, 0, ... (26 нулей), 1, 0, 0, 1].

После всего этого сгенерированный Gold Sequence добавляется к входному набору бит: $$ \tilde{b}^{(q)}(i) = (b^{(q)}(i) + c^{(q)}(i)) \mod 2 $$

Тут на самом деле намного проще смотреть уже на код, а не на формулы, поэтому:

```python
import math
import matplotlib.pyplot as plt

b = [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1]
RNTI = 5
q = 0
N_cell_id = 133
n_s = 0
Nc = 1600
sequence_length = len(b) 

c_init = RNTI * (2 ** 14) + q * (2 ** 13) + math.floor(n_s / 2) * (2 ** 9) + N_cell_id
c_init_binary = bin(c_init)[2:].rjust(32, "0") 

c = [0] * sequence_length
x_1 = [0] * (32 + Nc + sequence_length)
x_2 = [0] * (32 + Nc + sequence_length)

x_1[0] = 1
x_1[30] = 0

for i, bit in enumerate(c_init_binary):
    x_2[i] = int(bit)

for n in range(Nc + sequence_length):
    x_1[n + 31] = (x_1[n + 3] + x_1[n]) % 2
    x_2[n + 31] = (x_2[n + 3] + x_2[n + 2] + x_2[n + 1] + x_2[n]) % 2

for n in range(sequence_length):
    c[n] = (x_1[n + Nc] + x_2[n + Nc]) % 2

b_hat = [(b[i] + c[i]) % 2 for i in range(len(b))]
```

Если отрисовать как $$ c $$, $$ b $$ и $$ \tilde{b} $$ относятся друг к другу, то мы увидим следующую картину: (PHY Scrambling Bit Diagram) https://imgur.com/a/ptgfM4Z. На диаграмме можно заметить, что значение результата не содержит в себе повторяющихся больше 3 раз битов. Тут я вас призываю поиграться со входными параметрами и посмотреть, как будет изменяться результат. Вы увидите, что в нем никогда не будет большого количества повторений нулей или едениц. Это нужно для избежания проблем из-за отсутсвия перехода состояний, например потери синхронизации или появления DC Offset в передатчике.

Также scrambling позволяет уменьшить интерференцию, добавляя больше разницы в сигналах между разными пользователями. Для других пользователей сигнал друг друга будет являться рандомным шумом, он будет редко совпадать, соответсвенно не вызывая корреляцию и интерференцию.

##### 1.1.5.2. Modulation Mapper

Этап модуляции. Тут в спецификации определено несколько доступных видов модуляции: QPSK (или 4QAM), 16QAM, 64QAM и 256QAM.

QAM мы уже разбирали в предыдущем разделе, смотрите Modulation.

##### 1.1.5.3. Layer Mapper

Этап преобразования комплексных смодулированных символов $$ d^{(q)}(0),\dots,d^{(q)}(M^{(q)}_{symb} - 1) $$ в набор отдельных потоков, уровней (или, как в документации, Layer'ов): 
$$
x(i) = \begin{vmatrix} 
  x^{(0)}(i) \\ 
  \vdots \\
  x^{(v-1)}(i)
\end{vmatrix}, \

i = 0,1,\dots,M^{layer}_{symb}-1
$$

где $$ M^{layer}_{symb} $$ - количество смодулированных символов для каждого уровня, а $$ v $$ - кол-во уровней.

###### 1.1.5.3.1. Layer Mapping для передачи на одной антенне

Он довольно прост: $$ x^{(0)}(i) = d^{(0)}(i) $$, при этом $$ M^{layer}_{symb} = M^{(0)}_{symb}` (тут `M^{(0)}_{symb} $$ - количество символов на первом потоке (codeword'е)).

Видно, что для одной антенны смодулированные значения вообще не проходят никакого преобразования и передаются на следующий этап напрямую.

###### 1.1.5.3.2. Layer Mapping для MIMO

Тут нужно посмотреть на таблицу 36.211 6.3.3.2-1, Codeword-to-layer mapping for spatial multiplexing. В ней указаны различные возможные конфигурации отправки, а именно: количество уровней (v) и количество входных потоков смодулированных символов (codeword'ов). 

В случае MIMO используется несколько антенн, поэтому есть и ограничение на количество уровней: оно должно быть меньше или равно количеству антенн P. 

Расммотрим несколько случаев Layer Mapping для MIMO:

 1. $$ v=4 $$ (кол-во уровней), $$ q=2 $$ (кол-во codeword'ов): 
$$
\begin{align*}
  & x^{(0)}(i) = d^{(0)}(2i) \\
  & x^{(1)}(i) = d^{(0)}(2i + 1) \\ 
  & x^{(2)}(i) = d^{(1)}(2i) \\ 
  & x^{(3)}(i) = d^{(1)}(2i+1)
\end{align*}, \ M^{layer}_{symb} = M^{(0)}_{symb} / 2 = M^{(1)}_{symb}/2
$$
 О чем говорит эта формула: на уровень 0 распределяются все символы с чётными номерами из входного codeword'а 0; на уровень 1 распределяются все символы с нечётными номерами из входного codeword'а 0, и так далее. То есть здесь идёт простое ранвомерное распределение элементов входного потока на несколько отдельных потоков.

 2. Такое простое распределение справедливо и для других конфигураций, например возьмем $$ v=8 $$, $$ q=2 $$:
$$
\begin{align*}
  & x^{(0)}(i) = d^{(0)}(4i) \\
  & x^{(1)}(i) = d^{(0)}(4i + 1) \\ 
  & x^{(2)}(i) = d^{(0)}(4i + 2) \\ 
  & x^{(3)}(i) = d^{(0)}(4i+3) \\
                \\
  & x^{(4)}(i) = d^{(1)}(4i) \\
  & x^{(5)}(i) = d^{(2)}(4i + 1) \\ 
  & x^{(6)}(i) = d^{(3)}(4i + 2) \\ 
  & x^{(7)}(i) = d^{(4)}(4i+3) \\
\end{align*} \ M^{layer}_{symb} = M^{(0)}_{symb} / 4 = M^{(1)}_{symb} / 4
$$

 Тут уже символы распределяются между восемью уровнями, действует такая же логика, как и в первом случае: на уровень 0 распределяются все символы с номерами, кратными 4 из входного codeword'а 0; на уровень 1 распределяются все те символы, которые следуют за символами с номерами, кратными 4 из входного codeword'а 0, и так далее.

###### 1.1.5.3.3. Layer Mapping для Diversity

С Diversity мы разбирались ранее. Кто не помнит, это когда несколько антенн вещают один и тот же сигнал (он также может быть смещён, помним Large Delay CDD).

Здесь работает такая же логика, как и для Layer Mapping для MIMO. Однако действует другая таблица: 6.3.3.3-1 и другое ограничение на количество уровней: оно должно быть строго равно кол-ву антенн P.

Интерес вызывает случай $$ v=4 $$, $$ q=1 $$:
$$
\begin{align}
  & x^{(0)}(i) = d^{(0)}(4i) \\
  & x^{(1)}(i) = d^{(0)}(4i + 1) \\ 
  & x^{(2)}(i) = d^{(0)}(4i + 2) \\ 
  & x^{(3)}(i) = d^{(0)}(4i+3) \\
\end{align} \\
M^{layer}_{symb} = \begin{cases} 
  M^{(0)}_{symb} / 4 \text{ if } M^{(0)}_{symb} \mod 4 = 0 \\
  (M^{(0)}_{symb} + 2) / 4 \text{ if } M^{(0)}_{symb} \mod 4 \neq 0
\end{cases}
$$

Если в MIMO подразумевалось, что количество символов в codeword всегда совпадает с тем, что ожидает Layer Mapper (т.е например для $$ v=8 $$, $$ q=2 $$ оно должно быть кратно 4, это условие исходит из второй части выражения, где определён $$ M^{layer}_{symb} $$), то тут такого нет и подразумевается, что количество символов в codeword'е будет просто чётно. 
Так вот, если количество символов не кратно 4, то во входной поток $$ d $$ добавляется 2 нулевых символа и действует вторая часть выражения определения $$ M^{layer}_{symb} $$).

Тут я тоже написал чтобы было проще понимать как работает этот этап:

```python
import numpy as np
import modulation

symbols = modulation.modulate_bits([0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1])
d = np.array([ symbols ])

def mapping_dimension(v, q):
    return ((v // q), v - (v // q))

def layer_mapper(d, v):
    dimension = mapping_dimension(v, len(d))
    M_layer_symb = len(d[0]) // dimension[0]
    x = [
        [0] * M_layer_symb
        for _ in range(v)
    ]

    for layer in range(v):
        current_codeword = 0 if layer < dimension[0] else 1
        current_mod = dimension[0] if layer < dimension[0] else dimension[1]
        for i in range(M_layer_symb):
            x[layer][i] = d[current_codeword][current_mod * i + layer]
            print(current_mod)

    return x

print(layer_mapper(d, 3))
```

И также сделал такую иллюстрацию, где собрал вместе все таблицы. К ней можно обращаться чтобы удобно видеть всю информацию про Layer Mapping: (PHY Layer Mapping) https://imgur.com/a/ptgfM4Z.

##### 1.1.5.4. Precoding

С этим этапом мы уже разбирались ранее, это как раз тот этап преобразования сигнала используя codebook.

##### 1.1.5.5. Mapping to resource elements

Размещение каждого символа в свои соотвествующие места в Resouse Grid. Т.е распределение символов по времени и частоте. Каждый канал занимает своё место в Resource Grid, здесь они отмечены цветами: (Resource Grid) https://imgur.com/a/4FquDey.

##### 1.1.5.6. Physical Downlink Shared Channel (36.211 6.4)

PDSCH это физический канал, предназначенный для передачи пользовательских данных. Для этого канала действует стандартная процедура генерации сигнала, описанная выше. Однако есть и некоторые детали, уникальные для этого канала:

 1. В Resource Block'ах, в которых отправляется UE-Specific Reference Signal, PDSCH должен быть отправлен используя антенны {5}, {7}, {8}, {11}, {13}, {11,13}, или {7, 8, ..., v+6}, где $$ v $$ - кол-во уровней для PDSCH.
 2. В Resourse Block'ах, в которых UE-Specific Reference Signal не отправляется, PDSCH должен быть отправлен используя антенны {0}, либо {0,1}, либо {0, 1, 2, 3}. 

    Заметка: про UE-Specific Reference Signal будем говорить позже, в разделе про сигналы.
 3. PDSCH не должен быть назначен любым парам PRB в которых передаётся EPDCCH (про PDCCH и EPDCCH позже).
 4. Для Frame Structure type 1 (FDD), PDSCH на 5 антенне не должен занимать PRB в которых находится PBCH или PSS/SSS.

##### 1.1.5.7. Physical Multicast Channel (36.211 6.5)

PMCH - канал использующийся для передачи данных сразу нескольким выбранным пользователям. Для него действует стандартная процедура, описанная ранее со следющими исключениями:

 1. Transmit Diversity не должен быть использован при передаче данных по этому каналу
 2. Layer Mapping и Precoding должны быть осуществлены только предполагая, что для передачи данных будет использоваться одна антенна. 
 3. Для передачи этого канала должна быть использована антенна 4.
 4. Передача этого канала должна осуществляться только в специальных MBSFN subframe'ах. При этом номер RE в первом слоте $$ l $$ должен быть больше или равно, чем $$ l_{PMCHStart} $$, где $$ l_{PMCHStart} $$ указывается параметром non-MBSFNregionLength, который отправляется в SIB13 (про SIB позже)
 5. PMCH должен всегда использовать Extended Cyclic Prefix
 
##### 1.1.5.8. Physical Broadcast Channel (36.211 6.6)

PBCH - канал, использующийся для отправки MIB (Main Information Block). Для него действует немного другая процедура генерации сигнала.

 1. Scrambling. Для scrambling используется стандартная формула получения b_hat, однако отличается $$ c_{init} $$. В случае PBCH, $$ c_{init} = N^{cell}_{ID}`, где `N^{cell}_{ID} $$ - физический ID вышки. 
 Также стоит упомянуть, что количество бит во входном массиве будет равно 1920 для Normal Cyclic Prefix и 1728 для Extended Cyclic Prefix. 
 2. Modulation - PBCH использует только QPSK (4QAM), т.е два бита на каждый RE.
 3. Layer Mapping и Precoding - осуществляется только для одной антенны, либо Transmission Diversity. MIMO для этого канала никогда не используется. При этом для Precoding кол-во антенн P может быть равно только 1, 2 или 4.
 4. Mapping to resource elements - PBCH всегда отправляется в slot 1 в subframe 0. При этом: (PHY PBCH Resource Grid Mapping Formula) https://imgur.com/a/ptgfM4Z: 
$$
k = \frac{N^{DL}_{RB} N^{RB}_{sc}}{2} - 36+k', \ k' = 0,1,\dots,71 \\
l = 0,1,\dots,3
$$
 Т.е PBCH будет появляться в каждом slot 1, subframe 0 и будет занимать в нем первые 4 RE, за исключением Reference Signal и зарезервированных RE, за это отвечает $$ l $$. $$ k $$ отвечает за то, что канал будет передаваться ровно на 72 subcarrier'ах по центру Resource Grid. Чтобы это лучше понять, можно подставить значения: $$ N^{DL}_{RB} $$ - это количество PRB, которое зависит от Bandwith, $$ N^{RB}_{sc} $$ - это количество subcarrier в одном PRB (чаще всего 12). Таким образом, например, при BW=3, $$ N^{DL}_{RB}=15 $$, $$ N^{RB}_{sc}=12 $$, PBCH будет передан начиная с Subcarrier 54 до subcarrier `54+71=125`. Визуально это можно представить так: (PHY PBCH Resource Grid Mapping) https://imgur.com/a/ptgfM4Z. 

##### 1.1.5.9. Physical Control Frame Indicator Channel (36.211 6.7)

PCFICH - канал, предназаченный для отправки данных о структуре управляющих каналов, например PDCCH. По нему отправляется именно кол-во OFDM символов в них.

 1. Scrambling - Используется стандартная формула получения b_hat, однако $$ c_{init} $$ отличается. Он определяется так: $$ c_{init} = (\lfloor n_s/2 \rfloor + 1) \cdot (2N^{cell}_{ID} + 1) \cdot 2^9 + N^{cell}_{ID} $$: (PHY PCFICH Scrambling c_init) https://imgur.com/a/ptgfM4Z. Кол-во бит здесь будет равно 31.
 2. Modulation - PCFICH использует только QPSK
 3. Layer Mapping и Precoding - осуществляется также, как и в PBCH
 4. Mapping to resource elements - PCFICH отправляется группами по 4 RE. Каждый из 4 символов занимает своё место в Resource Grid. При этом меняется у них только положение по частоте, по времени PCFICH всегда находится в первом OFDM символе subframe'а. Рассмотрим процесс распределения символов по RG:
:::margin{ml=28}
  4.1. На вход подаётся 4 QPSK символа, обозначим их так: $$ \zeta^{(p)}(i) = \langle y^{(p)}(4i),y^{(p)}(4i+1),y^{(p)}(4i+2),y^{(p)}(4i+3) \rangle $$

  4.2. Каждому из них назначается своё значение $$ k $$, которое является номером subcarrier в кадре:
$$
\zeta^{(p)}(0) \rightarrow k = \bar{k} \\
\zeta^{(p)}(1) \rightarrow k = \bar{k} + \lfloor N^{DL}_{RB}/2 \rfloor \cdot N^{RB}_{sc} /2 \\
\zeta^{(p)}(2) \rightarrow k = \bar{k} + \lfloor 2N^{DL}_{RB}/2 \rfloor \cdot N^{RB}_{sc} /2 \\
\zeta^{(p)}(3) \rightarrow k = \bar{k} + \lfloor 3N^{DL}_{RB}/2 \rfloor \cdot N^{RB}_{sc} /2 
$$
  Здесь стоит заметить, что операция сложения выполняется с modulo $$ N^{DL}_{RB} N^{RB}_{sc} $$, я не стал добавлять это в формулу так как она была бы слишком громоздкой.

  4.3. Параметр $$ \bar{k} $$ генерируется так: $$ \bar{k} = \frac{1}{2} N^{RB}_{sc} \cdot (N^{cell}_{ID} \mod 2N^{DL}_{RB}) $$
:::

 Полную схему этого этапа я изобразил тут: (PHY PCFICH Resource Element Mapping) https://imgur.com/a/ptgfM4Z.
 И также можно посмотреть как это будет выглядеть в действии, тут зелёным обозначен как раз PCFICH: (PHY PCFICH Resource Element Mapping Example) https://imgur.com/a/ptgfM4Z.

##### 1.1.5.10. Physical Downlink Control Channel (36.211 6.8)

PDCCH - один из самых важных каналов. По нему идут данные DCI (Downlink Control Information), которые позволяют осуществлять выделение ресурсов, а также другие контроллирующие действия. К процедуре PDCCH мы ещё вернемся, сейчас пока что рассматриваем только физический уровень.

Данные, передающиеся по PDCCH организованы в CCE - Control Channel Elements, который содержит в себе 9 Resource Element Group. Организацию CCE и REG мы рассматривали до этого, в разделе про Resourse Grid. 

Существует несколько форматов PDCCH, они представлены в таблице 36.211 6.8.1-1:
```
╔════════╦══════╦════════════╦══════════════╗
║ Format ║ CCEs ║ RE Groups  ║ PDCCH Bits   ║
╠════════╬══════╬════════════╬══════════════╣
║   0    ║  1   ║     9      ║     72       ║
║   1    ║  2   ║    18      ║    144       ║
║   2    ║  4   ║    36      ║    288       ║
║   3    ║  8   ║    72      ║    576       ║
╚════════╩══════╩════════════╩══════════════╝
```

Тут видно, что каждый формат может нести в себе различное число бит. Такое разделение на форматы необходимо для обеспечения стабильности канала. Когда необходимо отправить малое количество данных, вышка будет использовать формат 0, когда необходимо будет отправить большое кол-во данных, будет использоваться формат 1,2 или 3. Чем меньше данных отправляется по каналу, и, соотвественно, считывается на UE, тем меньше может возникнуть ошибок в декодировании сигнала. А так как PDCCH - очень важный канал, который выполняет ключевую функцию LTE - просто необходимо обеспечить ему достаточную гибкость, чтобы даже в плохих условиях коммуникации можно было по этому каналу доставлять данные.

Теперь разберемся с этапами генерации сигнала:

 1. Scrambling - этот этап для PDCCH имеет достаточно интересный процесс: перед самим непосредственно Scrambling'ом, биты со всех потоков собираются (мультиплексируются (использую официальную терминологию)) в один большой поток бит, т.е: мы получаем на вход $$ i $$ потоков в виде: $$ b^{(i)}(0),\dots,b^{(i)}(M^{(i)}_{bit} - 1) $$, где $$ M^{(i)}_{bit} $$ - кол-во бит в текущем subframe, которые будут передаваться по PDCCH каналу с номером $$ i $$. На выходе с мультиплексирования мы будем иметь набор бит $$ b^{(0)}(0),\dots,b^{(0)}(M^{(0)}_{bit} - 1),b^{(1)}(0),\dots,b^{(1)}(M^{(1)}_{bit} -1),\dots,b^{(n_{PDCCH} -1)}(0),\dots,^{(n_{PDCCH} -1)}(M^{(n_{PDCCH}-1)}_{bit} -1) $$.
 Затем к этому набору бит будет применена стандартная формула scrambling, однако с изменённым $$ c_{init} $$: $$ c_{init} = \lfloor n_s / 2 \rfloor \cdot 2^9 + N^{cell}_{ID} $$
 При этом стоит заметить, что до scrambling'а до 9 нулевых элеметов могут быть добавлены к блоку чтобы PDCCH начинался с нужной CCE, но об этом позже, это уже часть процедуры PDCCH.
 2. Modulation - для PDCCH используется только QPSK
 3. Layer Mapping и Precoding - осуществляется также, как и PBCH

 4. Mapping to resource elements - Распределение символов для PDCCH также осуществляется по группам в 4 символа. Разберем этот процесс поэтапно, так как он достаточно сложный:
:::margin{ml=28}
  4.1. Для начала все символы после precoding разбиваются на группы по 4: $$ \zeta^{(p)}(i) = \langle y^{(p)}(4i),y^{(p)}(4i+1),y^{(p)}(4i+2),y^{(p)}(4i+3) \rangle $$

  4.2. Затем, следуя спецификации, массив групп четырех элементов преобразуется  согласно 36.121 5.1.4.2.1, Sub-block interleaver. Разберем этот процесс:
:::margin{ml=56}
   4.2.1. На вход sub-block interleaver подаётся массив элементов: $$ d^{(i)}_0, d^{(i)}_2, \dots, d^{(i)}_{D-1} $$, где $$ D $$ - кол-во элементов

   4.2.2. При этом, если количество элементов не кратно 32, то в начало массива добавляется $$ R^{CC}_{subblock} * C^{CC}_{subblock} - D $$ элементов NULL, которые по спецификации равны -1.

   4.2.3. Составляется матрица с количеством столбцов $$ C^{CC}_{subblock} = 32 $$ и количеством строк $$ R^{CC}_{subblock} = \lceil D / C^{CC}_{subblock} \rceil $$ и в неё записываются значения из полученного массива, заполнение начинается со строк. Т.е в результате предыдущих этапов у нас есть массив $$ y $$, кол-во элементов которого кратно 32 и его теперь мы преобразовываем в матрицу со сторонами $$ R^{CC}_{subblock} $$ и $$ C^{CC}_{subblock} $$

   4.2.4. Затем производится операция изменения порядка столбцов в соотвествии со следующим паттерном: `1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23, 15, 31,
0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30` (таблица 36.212 5.1.4-2). Это значит, что в 0-м столбце будет находится 1-й столбец, в 1-м - 17-й, во 2-м - 9-й, и т.д.

   4.2.5. После изменения порядка все элементы матрицы собираются в одномерный массив по столбцам (т.е сначала элемент 0 ряда 0 столбца, потом 1 ряда 0 столбца, потом 2 ряда 0 столбца и так до $$ R^{cc}_{subblock} $$ ряда 0 столбца, и т.д)

   Описание текстом довольно сложно понять, поэтому я написал реализацию в коде:
```python
import numpy as np

PERMUTATION_PATTERN = [1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23, 15, 31,
                       0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30]

def interleave(elements: list):
    D = len(elements)
    C_cc_subblock = 32
    R_cc_subblock = (D // C_cc_subblock) + 1
    dummy_bits = R_cc_subblock * C_cc_subblock - D

    y = [-1] * dummy_bits + elements
    y = np.array(y).reshape(R_cc_subblock, C_cc_subblock)

    result = np.zeros((R_cc_subblock, C_cc_subblock), dtype=int)
    
    for row in range(R_cc_subblock):
        for col in range(C_cc_subblock):
            result[row, col] = y[row, PERMUTATION_PATTERN[col]]

    return result.flatten(order="F").tolist()

if __name__ == "__main__":
    print(interleave([1, 2, 3, 4, 5, 6, 7, 8, 9] * 9))
```
  4.3. Затем все элементы NULL удаляются из полученного после sub-block interleaver массива
  4.4. После этого каждый элемент массива циклически сдвигается на $$ N^{cell}_{ID} $$ элементов:
```python
def cyclic_shift(elements: list, cell_id: int):
    result = [0] * len(elements)
    for i in range(len(elements)):
        result[i] = elements[(i + cell_id) % len(elements)]
    return result
```
:::

  Математически эту операцию можно выразить так: $$ \bar{w}^{(p)}(i) = w^{(p)}((i + N^{cell}_{ID}) \mod M_{quad}) $$, где $$ w $$ - результат sub-block interleaver.

:::margin{ml=28}
  4.5. Затем массив $$ \bar{w} $$ размещается в Resource Grid по REG по следующему алгоритму:
:::

:::margin{ml=30}
   4.5.1. Инициализируется m' = 0 (номер REG), k' = 0 
:::
:::margin{ml=42}
4.5.2. Инициализируется l' = 0 
:::
:::margin{ml=54}
4.5.3. Если REG (k', l') не назначен PCFICH или PHICH, то выполняется шаг 4.5.4, иначе выполняется шаг 4.5.6
:::
:::margin{ml=66}
4.5.4. Группа 4-х элементов $$ \bar{w}^{(p)}(m') $$ назначается на REG (k', l') для каждой антенны p (всех антенн в результате Precoding)

4.5.5. m' увеличивается на 1
:::
:::margin{ml=54}
4.5.6. l' увеличивается на 1

4.5.7. Если l' < L, где L - кол-во OFDM символов для PDCCH, т.е значение CFI, переданное по PCFICH, то надо повторить все действия, начиная с шага 4.5.3

4.5.8. k' увеличивается на 1

4.5.9. Если k' < $$ N^{DL}_{RB} \cdot N^{RB}_{sc} $$, то идём обратно на шаг 4.5.2.
:::

Я реализовал всю эту схему в коде, вот:
```python
import numpy as np
from channel_coding.sub_block_interleaver import interleave
from channels.symbol import ReferenceSignal, PDCCH, Reserved
import modulation, scrambling

NIL = (0, 0, 0, 0)

def cyclic_shift(elements: list, cell_id: int):
    result = [0] * len(elements)
    for i in range(len(elements)):
        result[i] = elements[(i + cell_id) % len(elements)]
    return result

def is_reg_complete(resource_grid: np.ndarray, k_start: int, l: int) -> bool:
    available = 0
    k = k_start
    while k < resource_grid.shape[0] and available < 4:
        if not isinstance(resource_grid[k, l], ReferenceSignal):
            available += 1
        k += 1
    return available == 4

def map_reg(resource_grid: np.ndarray, elements: list, k_start: int, l: int):
    i = 0
    k = k_start
    while i < 4 and k < resource_grid.shape[0]:
        if not isinstance(resource_grid[k, l], ReferenceSignal):
            resource_grid[k, l] = elements[i]
            i += 1
        k += 1

def map_quadruplets(resource_grid: np.ndarray, quadruplets: list, N_DL_RB: int, N_RB_sc: int, PDCCH_OFDM_symbols: int):
    m = 0
    k = 0
    while True:
        l = 0
        while True:
            can_be_assigned = k % 4 == 0 and is_reg_complete(resource_grid, k, l)
            if can_be_assigned:
                map_reg(resource_grid, list(quadruplets[m]), k, l)
                m += 1
            l += 1
            if l >= PDCCH_OFDM_symbols:
                break
        k += 1
        if k >= N_DL_RB * N_RB_sc:
            break

if __name__ == "__main__":    
    N_DL_RB = 15
    N_RB_sc = 12
    RE_in_frame = 140
    n_s = 0
    N_cell_id = 133
    PDCCH_OFDM_symbols = 1
    resource_grid = np.zeros((N_DL_RB * N_RB_sc, RE_in_frame), dtype=object)
    bits = list(np.random.binomial(1, 0.5, size=(72)))
    c_init = int(np.floor(n_s / 2)) * (2 ** 9) + N_cell_id

    required_bits = 2 * PDCCH_OFDM_symbols * N_DL_RB * N_RB_sc
    append_bits = required_bits - len(bits)
    for _ in range(append_bits // len(NIL)):
        bits.extend(NIL)

    scrambled_bits = scrambling.scramble(bits, c_init)
    modulated_symbols = modulation.modulate_bits(scrambled_bits, mu=2)
    precoded = modulated_symbols
    quadruplets = precoded.reshape((len(precoded) // 4, 4))
    interleaved = [symb for symb in interleave(list(quadruplets)) if not (symb is None)]
    shifted = [
        [PDCCH(v) for v in q]
        for q in cyclic_shift(interleaved, N_cell_id)
    ]

    for k in range(N_DL_RB * N_RB_sc):
        prb_sc = k % N_RB_sc
        if prb_sc == 5 or prb_sc == 11:
            resource_grid[k, 0] = ReferenceSignal(0)

    map_quadruplets(resource_grid, shifted, N_DL_RB, N_RB_sc, PDCCH_OFDM_symbols)
    for row in resource_grid:
        print(row[0])

```

 И опять, сделал иллюстрацию, где собрал все формулы воедино: (PHY PDCCH) https://imgur.com/a/ptgfM4Z

##### 1.1.5.11. Physical HARQ Indicator Channel (36.211 6.9)

PHICH - канал по которому передаются hybrid-ARQ ACK/NACK. HARQ - это процесс, при котором базовая станция принимая данные отвечает устройству двумя возможными ответами: ACK и NACK. ACK означает, что данные были приняты успешно, а NACK - что необходима переотправка. Впрочем про LTE процедуры мы будем говорить отдельно, сейчас только физическая составляющая канала.

У этого канала есть своя особенность. Нескольким потокам PHICH могут быть назначены одинаковые RE. Тут можно задать вопрос: "а как тогда сигнал вообще можно декодировать?". На это есть ответ: каждому PHICH назначается свой ортогональный код. Кто знаком с, например WCDMA или CDMA, тот понимает о чем речь. В них тоже использовались ортогональные коды для передачи разных данных на одинаковой частоте в одно и то же время. 
Идея проста: придумать такие последовательности значений, которые если мы будем применять к одному и тому же сигналу, то будем получать разные валидные данные. Сейчас это и рассмотрим.

Соотвественно канал PHICH, так как может отправляться на одних и тех же RE, определяется двумя параметрами: $$ n^{group}_{PHICH} $$ и $$ n^{seq}_{PHICH} $$. Тут $$ n^{group}_{PHICH} $$ - номер группы PHICH и $$ n^{seq}_{PHICH} $$ - номер ортогонального кода. Группа PHICH - это как раз набор потоков PHICH, которым назначен один и тот же набор RE.

UE знает сколько попыток декодирования осуществлять благодаря параметру $$ N^{group}_{PHICH} $$, который указывает на количество PHICH групп в каждом subframe. Вычисляется он так: 
$$
N^{group}_{PHICH} = \begin{cases} 
 \lceil N_g (N^{DL}_{RB} / 8) \rceil, \text{ для Normal Cyclic Prefix} \\ 
 2 \cdot \lceil N_g (N^{DL}_{RB} / 8) \rceil, \text{ для Extended Cyclic Prefix} \\ 
\end{cases}
$$
где $$ N_g $$ идёт из MIB, поле `phich-Config.phich-Resource`.

Теперь рассмотрим саму процедуру генерации. Можете сразу смотреть на иллюстрацию (PHY PHICH) https://imgur.com/a/ptgfM4Z, там указаны все формулы и таблицы:

 1. Modulation - используется только BPSK (т.е один бит на один символ, 2-QAM). После модуляции мы получаем набор символов $$ \zeta(0),\dots,\zeta(M_s - 1) $$, где $$ M_s = M_bit$$, т.е кол-во отправляемых на PHICH бит.
 2. Orthogonal Code Multiplexing - к набору смодулированных символов $$ \zeta $$ применяется один из ортогональных кодов по формуле $$ d(i) = w(i \mod N^{PHICH}_{SF}) \cdot (1-2\times c(i)) \cdot \zeta(\lfloor i/N^{PHICH}_{SF} \rfloor)`, где `i = 0,\dots,M_{symb}-1 $$, $$ M_{symb} = N^{PHICH}_{SF} \cdot M_s $$, а $$ N^{PHICH}_{SF} = 4 $$ при использовании normal cyclic prefix и $$ 2 $$ при extended cyclic prefix. Тут $$ M_{symb} $$ - кол-во смодулированных символов, а $$ c(i) $$ - Scrambling Sequence со своим заданным $$ c_{init} $$: $$ c_{init} = (\lfloor n_s /2 \rfloor +1) \cdot (2N^{cell}_{ID} + 1) \cdot 2^9 + N^{cell}_{ID} $$.
   При этом в формуле можно было заметить массив $$ w $$ - это как раз таки и есть ортогональный код. Он определён в таблице 36.211 6.9.1-2. Выбор $$ n^{sec}_{PHICH} $$ делается так, чтобы он не совпадал с уже выбранными значениями этой переменной.
 3. Resource group alignment - уникальный для этого канала этап перед layer mapping и precoding. В нем элементы массива "d" преобразуются чтобы совпадать с размером REG. При этом при использовании normal cyclic prefix массив "d" остаётся неизменным, а при использовании extended cyclic prefix он подвергается изменениям в соотвествии со следующей формулой: 
$$
\begin{bmatrix} 
  d^{(0)}(4i) \\
  d^{(0)}(4i + 1) \\
  d^{(0)}(4i + 2) \\
  d^{(0)}(4i + 3) 
\end{bmatrix} = \begin{cases}
  \begin{bmatrix}
    d(2i) \\
    d(2i + 1) \\
    0 \\ 
    0
  \end{bmatrix} \text{ если } n^{group}_{PHICH} \mod 2 = 0 \\
   \begin{bmatrix}
    0 \\ 
    0 \\
    d(2i) \\
    d(2i + 1) 
  \end{bmatrix} \text{ если } n^{group}_{PHICH} \mod 2 = 1
\end{cases}
$$

  4. Layer Mapping и Precoding - осуществляется также, как и в PBCH. Изменение есть только для Diversity при $$ P = 4 $$, но там просто немного изменилась Precoding матрица, ничего особенного.
  5. Mapping to resource elements - для начала все символы с каждого потока для антенны суммируются. Это нужно для применения ортогональных кодов: $$ \bar{y}^{(p)}(n) = \sum{y^{(p)}_i(n)} $$.
:::margin{ml=28}
   Распределение PHICH символов осуществляется по Mapping Unit'ам. Для каждой PHICH группы создаётся свой mapping unit. В случае extended CP, mapping unit будет являться суммой двух элементов $$ \hat{y} $$, т.е суммой $$ \hat{y}^{(p)}_m(n) + \hat{y}^{(p)}_{m+1}(n) $$. Тут за $$ \hat{y}^{(p)}_m(n) $$ обозначена PHICH группа "m" на антенне "p".

   Далее происходит уже известная нам процедура разделения элементов на группы по 4: $$ \zeta^{(p)}(i) = \langle \tilde{y}^{(p)}(4i),\tilde{y}^{(p)}(4i+1),\tilde{y}^{(p)}(4i+2),\tilde{y}^{(p)}(4i+3) \rangle $$

   При этом эти группы 4-х элементов также обладают ещё одним параметром - PHICH mapping unit'ом, т.е номером группы.

   После этого выполняется следующий алгоритм:
:::

:::margin{ml=40}
5.1. Для каждого значения l' (это кол-во OFDM символов в subframe)
:::
:::margin{ml=52}
5.2. Пусть n_l - кол-во REG, не выделенных для PCFICH в OFDM символе l'

5.3. Пронумеровать REG, не выделенные для PCFICH в OFDM символе l' от 0 до n_l - 1, начиная от REG с наименьшей частотой (т.е снизу RG)
:::
:::margin{ml=40}
5.4. m' = 0 (PHICH mapping unit)

5.5. Для каждого значения i=0,1,2:
:::
:::margin{ml=52}
5.6. l' = 0 для каждого subframe

5.7. Определить номер REG по следующей формуле:

$$
\bar{n}_i = \begin{cases} 
  (\lfloor N^{cell}_{ID} \cdot n_{l_i'}/n_1 \rfloor + m') \mod n_{l_i'} & i=0 \\
  (\lfloor N^{cell}_{ID} \cdot n_{l_i'}/n_1 \rfloor + m' +\lfloor n_{l_i'} /3 \rfloor) \mod n_{l_i'} & i=1 \\
  (\lfloor N^{cell}_{ID} \cdot n_{l_i'}/n_1 \rfloor + m' +\lfloor 2n_{l_i'} /3 \rfloor) \mod n_{l_i'} & i=2 \\
\end{cases}
$$

5.8. По номеру REG определить частоту REG и назначить группу из 4 символов к найденному REG с (k', l')
:::
:::margin{ml=40}
5.9. m += 1

5.10. Повторить с этапа 5.5 пока всем PHICH mapping unit'ам не будут назначены REG.
:::

----------------

Вот мы и разобрались со всеми физическими каналами. В следующем посту соберем все эти каналы воедино в коде, также рассмотрим Uplink каналы (там всё немного проще) и затем перейдем к великим и ужасным сигналам (не все там так ужасно, точно не сложнее чем каналы, а каналы не такие уж и сложные в целом)

---------------------------------------------------------------------------------
:::margin{variant=note}
Заметки для себя: 
  1. Потом упомянуть про MUST interference presence and power ration, 6.3.3. Layer Mapping будет осуществляться по-другому
  2. Когда будем говорить про Rate Matching PBCH, надо будет обратить внимание на кол-во бит. Оно будет равно 240. Однако в Scrambling оно указано как 1920. Это из-за того, что в значение 1920 входят все 4 передачи (PBCH повторяется 4 раза, каждый раз по 240 бит). А из-за того, что PBCH использует QPSK, т.е на каждый RE приходится два бита, то и получается `240 * 4 * 2 = 1920`
  3. В этапе 4.5.7. PDCCH Resource Mapping есть исключения для MBSFN, см. 36.211 6.8.5
  4. EPDCCH
  5. BL/CE UEs
  6. MPDCCH
  7. SPDCCH
:::
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

#### 1.1.6. Physical Uplink Channels

(В прошлый раз мы разобрались со всеми физическими Downlink каналами LTE. Сегодня мы продолжаем копаться в физическом уровне, но на этот раз будем уже смотреть на Uplink каналы связи, т.е на те, которые использует устройство для отправки данных на вышку)

Для начала давайте разберемся с тем, как выглядит Frame Structure для Uplink. Сначала лучше взглянуть на иллюстрацию: (PHY Uplink Frame Structure) https://imgur.com/a/ptgfM4Z. 

На ней хорошо видно различия между Uplink Frame Structure и Downlink Frame Structure: в случае downlink каждый канал растянут больше по частоте, а в случае uplink каналы более локализованы. Например, PUCCH: он находится только в нижнем и верхнем концах BW.

Как и в случае с downlink, тут действуют следующие правила Frame Structure:
 1. В каждом Frame находится 9 subframe
 2. Минимальная еденица выщания - RE
 3. 12 subcarrier x 7 symbol (6 при Extended CP) организуют Resource Block
 4. Slot содержит 7 символов по времени и `N^{UL}_{RB} \times N^{RB}_{sc}` subcarrier'ов.

Теперь давайте разбираться с каждым Uplink каналом по отдельности.

##### 1.1.6.1. PUSCH - Physical Uplink Shared Channel

PUSCH - канал, по которому передаются данные пользователя, а также ACK/NACK для принятых с PDSCH данных. Генерация сигнала для этого канала производится следующим образом: (на диаграмме изображены этапы генерации)

```
codewords                                               
    │         User Data                                 
    └────────────►│b[q](0),b[q](1),...,b[q](M[q](bit)-1)
                  ▼                                     
      ┌────────────────────────┐                        
      │       Scrambling       │                        
      │      36.211 5.3.1      │                        
      └───────────┬────────────┘                        
                  │B[q](0),...,B[q](M[q](bit)-1)        
                  ▼                                     
      ┌────────────────────────┐                        
      │    Modulation Mapper   │                        
      │      36.211 5.3.2      │                        
      └───────────┬────────────┘                        
                  │d[q](0),...,d[q](M[q](symb)-1)       
                  ▼                                     
      ┌────────────────────────┐                        
      │      Layer Mapper      │                        
      │     36.211 6.3.2A      │                        
      └───────────┬────────────┘                        
                  │[x[0](i),...,x[a-1](i)]^T            
                  ▼                                     
      ┌────────────────────────┐                        
      │   Transform Precoder   │                        
      │      36.211 5.3.3      │                        
      └───────────┬────────────┘                        
                  │[y[0](i),...,y[v-1](i)]^T            
                  ▼                                     
      ┌────────────────────────┐                        
      │        Precoding       │                        
      │     36.211 5.3.3A      │                        
      └───────────┬────────────┘                        
                  │[z[0](i),...,z[P-1](i)]^T            
                  │                                     
                  ▼                                     
      ┌────────────────────────┐                        
      │Resource Element Mapper │                        
      │      36.211 5.3.4      │                        
      └───────────┬────────────┘                        
                  │s[p](l)(t)                           
                  ▼                                     
      ┌────────────────────────┐                        
      │   SC-FDMA Signal Gen.  │                        
      │      36.211 5.6        │                        
      └────────────────────────┘                        
```

###### 1.1.6.1.1. PUSCH Scrambling

Scrambling принимает набор бит $$ b^{(q)}(0),\dots,b^{(q)}(M^{(q)}_{bit} - 1) $$ и результатом является набор бит $$ \tilde{b}^{(q)}(0),\dots,\tilde{b}^{(q)}(M^{(q)}_{bit} - 1) $$, где $$ M^{(q)}_{bit} $$ - кол-во бит в codeword $$ q $$ на PUSCH в одном subframe.

Scrambling осуществляется по следующему алгоритму:
1. i = 0
2. Пока i < $$ M^{(q)}_{bit} $$
 3. Если $$ b^{(q)}(i) $$ относится к битам ACK/NACK или Rank Indicator (про него потом) placeholder
  4. То $$ \tilde{b}^{(q)}(i) $$ = 1
 5. Иначе
  6. Если $$ b^{(q)}(i) $$ относится к битам повтора ACK/NACK или Rank Indicator placeholder
   7. То $$ \tilde{b}^{(q)}(i) = \tilde{b}^{(q)}(i-1) $$
  8. Иначе $$ \tilde{b}^{(q)}(i) = (b^{(q)}(i-1) + с^{(q)}(i)) \mod 2 $$
 9. i += 1

При этом тут есть Pseudo-random Gold Sequence $$ c^{(q)}(i) $$ - для неё есть свой $$ c_{init} $$. Он определяется так: $$ c_{init} = n_{RNTI} \cdot 2^{14} + q \cdot 2^{13} + \lfloor n_s / 2 \rfloor \cdot 2^9 + N^{cell}_{ID} $$

Привожу реализацию в коде, так понять что происходит проще:
```python
import numpy as np
import scrambling

class InputBit:
    value: int

    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return f"{self.__class__.__name__}({self.value})"
    def __str__(self):
        return f"{self.__class__.__name__}({self.value})"

class PlaceholderBit(InputBit): pass
class PlaceholderRepetitionBit(InputBit): pass
class DataBit(InputBit): pass

def scramble(bits: list[InputBit], q: int, n_rnti: int, N_Cell_id: int, n_s: int):
    c_init = n_rnti * (2 ** 14) + q * (2 ** 13) + int(np.floor(n_s / 2)) * (2 ** 9) + N_Cell_id
    c = scrambling.get_scrambling_sequence(c_init, len(bits))
    b_hat = [0] * len(bits)

    for i in range(len(bits)):
        bit = bits[i]
        if isinstance(bit, PlaceholderBit):
            b_hat[i] = 1
        else:
            if isinstance(bit, PlaceholderRepetitionBit):
                b_hat[i] = b_hat[i - 1]
            else:
                b_hat[i] = (bit.value + c[i]) % 2

    return b_hat

if __name__ == "__main__":
    bits = [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]
    for i, b in enumerate(bits):
        if i < 3: bits[i] = PlaceholderBit(b)
        if 3 <= i < 6: bits[i] = PlaceholderRepetitionBit(b)
        if i >= 6: bits[i] = DataBit(b)

    q = 0
    n_rnti = 2
    N_cell_id = 133
    n_s = 0
    
    scrambled = scramble(bits, q, n_rnti, N_cell_id, n_s)
    print(scrambled)
```

###### 1.1.6.1.2. PUSCH Modulation

Для PUSCH используются только следующие виды модуляции: QPSK, 16QAM, 64QAM, 256QAM, pi/2 BPSK. Ничего особенного.

###### 1.1.6.1.3. PUSCH Layer Mapping

Осуществляется также, как и для downlink каналов. Отличие заключается только в том, что кол-во уровней $$ v $$ ограничено 4-м, а формулы для них там такие же.

И да, здесь не поддерживается Transmit Diversity. Только либо одна антенна, либо Spatial Multiplexing (т.е MIMO)

###### 1.1.6.1.4. PUSCH Precoding

Этот этап для PUSCH имеет достаточно много различий: во первых он разбит на два шага: Transform Precoding и Precoding, а также в нем используются другие матрицы из codebook, сейчас это разберем.

* 1.1.6.1.4.1. Transform Precoding

1. На вход полчуает набор комплексных чисел $$ x^{(\lambda)}(0),\dots,x^{(\lambda)}(M^{layer}_{symb} - 1), \lambda=0,1,\dots,v-1 $$, где $$ M^{layer}_{symb} $$ - кол-во символов на одном уровне, а $$ v $$ - кол-во уровней. 
2. Для каждого уровня производится разбиение на $$ M^{layer}_{symb}/M^{PUSCH}_{sc} $$ групп, другими словами на SC-FDMA символы (т.е на один time-domain символ).
3. Затем над символами производится следующая операция:
$$
y^{(\lambda)}(l \cdot M^{PUSCH}_{sc} + k) = \frac{1}{\sqrt{M^{PUSCH}_{sc}}} \sum^{M^{PUSCH}_{sc} - 1}_{i=0}{x^{(\lambda)}(l \cdot M^{PUSCH}_{sc} +i)}e^{-j\frac{2\pi \cdot ik}{M^{PUSCH}_{sc}}} \\
k = 0,\dots,M^{PUSCH}_{sc}-1 \\ 
l = 0,\dots,M^{layer}_{symb}/M^{PUSCH}_{sc}-1
$$

Объясняю: в формуле можно заметить интересную индексацию: $$ l * M^{PUSCH}_{sc} + k $$, например. Это индексация в матрице, где номер столбца - $$ k $$, а номер ряда - $$ l $$. Поэтому по сути то, о чем говорит эта формула - это то что надо для каждого ряда разбитых ранее элементов произвести операцию суммирования с умножением на экпоненциальный коэфициент, приведённый во второй части формулы. При этом результат этого суммирования умножить на $$ \frac{1}{\sqrt{M^{PUSCH}_{sc}}} $$. Текстом это точно не очень понятно, поэтому приведу реализацию в коде:
```python
def transform_precoding(x: np.ndarray, M_pusch_sc: int):
    grouped = x.reshape((len(x) // M_pusch_sc, M_pusch_sc))
    y = np.zeros_like(x, dtype=complex)

    for l in range(grouped.shape[0]):
        for k in range(grouped.shape[1]):
            group_sum = sum([grouped[l][i] * np.exp(-1j * 2 * np.pi * i * k / M_pusch_sc) for i in range(M_pusch_sc)])
            y[l * M_pusch_sc + k] = (1 / np.sqrt(M_pusch_sc)) * group_sum

    return y
```

При этом вы могли уже кричать, что эта часть формулы с суммированием - это обычный :glossary[FFT]. Да. Код можно оптимизировать и использовать уже готовую формулу FFT:
```python
def transform_precoding(x: np.ndarray, M_pusch_sc: int):
    grouped = x.reshape((len(x) // M_pusch_sc, M_pusch_sc))
    y = np.zeros_like(x, dtype=complex)

    for l in range(grouped.shape[0]):
        fft = np.fft.fft(grouped[l])
        y[l * M_pusch_sc : (l + 1) * M_pusch_sc] = (1 / np.sqrt(M_pusch_sc)) * fft

    return y
```

Этот этап нужен для создания :glossary[SC-FDMA] сигнала, ведь, как я и писал ранее, SC-FDMA - это версия OFDMA, в который добавляется дополнительный этап DFT. SC-FDMA более эффективный с точки зрения затрат энергии, так как имеет более низкий PAPR (Peak To Average Power Ratio) - т.е отношение максимальной мощности сигнала к средней. Он используется только на uplink именно для уменьшения расхода батареи. На базовой станции экономить энергию незачем, поэтому там используется стандартный OFDM. (в 5g NR кстати OFDMA может использоваться в направлении uplink тоже, но об этом позже)

И да, чтобы хоть как-то интуитивно понять SC-FDMA, попробуйте представить как символы распределяются в OFDM: каждый отдельный символ получает свой конкретный subcarrier и передаётся на нем. Если в этот процесс добавить DFT, то каждый символ будет растянут по частоте и передан последовательно. Отсюда SC-FDMA и имеет своё название: Single-Carrier, так как он "симулирует" характеристики QAM сигнала с одной поднесущей.

* 1.1.6.1.4.2. Precoding

На этом этапе не происходит ничего уникального, чего мы бы не разбирали ранее. Используются лишь другие наборы Precoding матриц. Их все я приведу в иллюстрации с общей процедурой генерации сигнала.

###### 1.1.6.1.5. PUSCH Mapping to physical resources

PUSCH назначается всем RE в subframe за исключением:
 1. RE, назначенным RS
 2. RE в последнем SC-FDMA символе в subframe, если он используется для передаче SRS
 3. RE в первом SC-FDMA символе slot'а если в DCI поле starting position содержит значения 01, 10, 11 и PUSCH Mode != 2
 4. RE в последнем SC-FDMA символе subframe'а или втором slot если в DCI поле ending symbol содержит 0 и Mode=3

При этом назначение к RE (k, l) назначается в порядке увеличения сначала значения k (т.е частоты), потом значения l (т.е времени).

Тут только стоит заметить, что есть одна деталь, которую я сейчас намеренно упущу: Frequency Hopping. Это фича конкретно этого канала, которая позволяет выделенным ресурсам постоянно менять расположение по частоте. Это может быть полезно, например, если некоторые частоты содержат в себе помехи. Если частота постоянно меняется, то в таком случае можно будет передать хоть какие-то данные на частотах, на которых нет помех. Остальные данные будут переотправленны благодаря процедуре HARQ.

Тут я сделал иллюстрацию, где указал все формулы и матрицы, используемые для PUSCH: (PHY PUSCH) https://imgur.com/a/ptgfM4Z.

##### 1.1.6.2. PUCCH - Physical Uplink Control Channel

PUCCH - канал, по которому передаются UCI (Uplink Control Information). UCI используются для ACK/NACK, а также запросов на выделение ресурсов. Сейчас мы рассматриваем только физический уровень, поэтому не будем заострять на этом внимание.

Этот канал уникален тем, что у него есть несколько форматов, а именно: 1, 1a, 1b, 2, 2a, 2b, 3, 4 и 5. Каждый из форматов применяется для отправки разных данных. Сейчас так как мы рассматриваем только физический уровень, не будем затрагивать какие конкретно данные отправляются по какому формату, рассмотрим только генерацию сигнала.

Для каждого формата определены параметры модуляции и кол-ва бит в subframe в таблице 36.211 5.4-1: (PHY PUCCH fortmats parameters) https://imgur.com/a/ptgfM4Z.

Сразу хочу заметить, что в коде в местах генерации параметра `l` есть один нюанс: сейчас там не учитываются сигналы DMRS. Я намеренно убрал их чтобы не усложнять код на этом этапе. В разделе про сигналы это рассмотрим.

* 1.1.6.2.1. PUCCH Format 1, 1a, 1b

Форматы 1, 1a и 1b предназначены для передачи всего одного или двух бит данных, например для Scheduling Request или HARQ ACK/NACK.

Передача данных для формата 1 осуществляется отсутствием либо присутсвием сигнала в RE. Если он есть, значит один модулированный символ `d(0) = 1`.

Для форматов 1a или 1b массив бит $$ b(0),\dots,b(M_{bit} - 1) $$ модулируется согласно таблице 36.211 5.4.1-1: (PHY PUCCH Format 1a, 1b Modulation) https://imgur.com/a/ptgfM4Z. На выходе мы также будем иметь лишь один смодулированный символ $$ d(0) $$. В таблице указан формат и набор бит для модуляции. Например, для формата 1b набор бит 01 будет преобразован в один смодулированный символ $$ d(0) = -j $$.

Дальше один символ `d(0)`, для каждой антенны P, 12 умножается на массив $$ r^{(\alpha_{\tilde{p}},\delta)}_{u,v}(n) $$. Математически это можно записать следующим образом: 
$$ 
y^{(\tilde{p},\delta)}(n) = \frac{1}{\sqrt{P}}d(0) \cdot r^{(\alpha_{\tilde{p}}, \delta)}_{u, v}(n), \ n = 0,1,\dots,N^{PUCCH}_{seq} - 1, \ \delta = 0 
$$
 где $$ N^{PUCCH}_{seq} = 12 $$ - длина массива $$ r^{(\alpha_{\tilde{p}},\delta)}_{u,v}(n) $$.

Допустим кол-во антенн $$ P $$ у нас равно 1. Формула говорит о том, что мы символ $$ d(0) $$ ровно 12 раз умножаем на следующий элемент массива $$ r $$ и записываем это всё в соответствующий элемент массива $$ y $$.

Тут можно спросить: "а что такое $$ r^{(\alpha_\tilde{p},\delta)}_{u,v}(n) $$?". Ответ убил: это Reference Signal Sequence. И сейчас мы НЕ будем разбираться как он генерируется, так как будем углубляться в этот sequence в разделе про сигналы. Поверьте, там очень интересно. Сейчас пока просто будем математически использовать этот массив, не зная как он работает под капотом.

Так вот, дальше к полученному массиву символов $$ y^{(\tilde{p})}(0),\dots,y^{(\tilde{p})}(N^{PUCCH}_{seq} - 1) $$ применяется scrambling и ортогональный код антенны. Сначала запишем это математически: 
$$ 
\zeta^{(\tilde{p})}(m' \cdot N^{PUCCH}_{SF} \cdot N^{PUCCH}_{seq} + m \cdot N^{PUCCH}_{seq} + n) = S(n_s) \cdot w_{n^{(\tilde{p})}_{oc}}(m) \cdot y^{(\tilde{p})}(n) 
$$ 
где $$ m = 0,\dots,N^{PUCCH}_{SF} - 1 $$, $$ n = 0,\dots,N^{PUCCH}_{seq} $$, $$ m' = 0,1 $$. $$ N^{PUCCH}_{SF} $$ меняется в зависимости от формата и номера слота в соответсвии с таблицей 36.211 5.4.1-1a:
```
╔═══════════════════╦═══════════════╦══════════════╗
║   PUCCH Format    ║ SF (1st Slot) ║ SF (2nd Slot)║
╠═══════════════════╬═══════════════╬══════════════╣
║ Normal 1/1a/1b    ║       4       ║      4       ║
║ Shortened 1/1a/1b ║       4       ║      3       ║
╚═══════════════════╩═══════════════╩══════════════╝
```

Тут нужно обратить внимание на $$ S(n_s) $$ и $$ w_{n^{(\tilde{p})}_{oc}}(m) $$. 

 1. $$ S(n_s) $$ - это массив для Scrambling'а. Он определяется следующим образом:
$$
S(n_s) = \begin{cases} 
  1 & \text{если } n'_{\tilde{p}}(n_s) \mod 2 = 0 \\
  e^{j \pi / 2} & \text{иначе}
\end{cases}
$$
 Где $$ n'_{\tilde{p}}(n_s) $$ - функция, которую сейчас дальше будем рассматривать.
 Если внимательно посмотреть на то, какие значения выбраны для Scrambling, то можно заметить, что в первом случае сигнал остаётся неизменным, а во втором - преобретает смещение по фазе на 90 градусов. Это необходимо для того, чтобы сразу несколько пользователей могли в одно и то же время на одной и той же частоте вещать разные данные. Сигнал с двух UE будет ортогонален друг к другу благодаря смещению по фазе на 90 градусов.

 2. $$ w_{n^{(\tilde{p})}_{oc}}(m) $$ - ортогональный код, который зависит от $$ N^{PUCCH}_{SF} $$ и $$ n^{(\tilde{p})}_{oc}(n_s) $$. Значение ортогональных кодов даны в таблицах 36.211 5.4.1-2 и 5.4.1-3: (PHY PUCCH Format 1 Orthogonal Sequences) https://imgur.com/a/ptgfM4Z.
 Опять же, значения в этих последовательносях выбраны ортогонально и для той же цели, что и scrambling. Дополнительный этап необходим для увеличения кол-ва возможных отправок на одних и тех же ресурсах.

Как вы могли заметить, scrambling зависит от `n'_{\tilde{p}}(n_s)`, получение ортогонального кода от `n^{(\tilde{p})}_{oc}(n_s)`, а применение reference signal sequence от `\alpha_{\tilde{p}}`. Сейчас разберем генерацию этих параметров.

 1. `n'_{\tilde{p}}(n_s)` - запишу сначала математически, потом объясню что это значит:

$$
n'_{\tilde{p}}(n_s) = \begin{cases}
 \begin{cases}
  n^{(1,\tilde{p})}_{PUCCH} & \text{если } n^{(1,\tilde{p})}_{PUCCH} < c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift} \\
  (n^{(1,\tilde{p})}_{PUCCH} - c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift}) \mod (c \cdot N^{RB}_{sc}/\Delta^{PUCCH}_{shift}) & \text{иначе}
 \end{cases} & \text{при } n_s \mod 2 = 0 \\
 \begin{cases}
  [c(n'_{\tilde{p}}(n_s - 1) + 1)] \mod (c \cdot N^{RB}_{sc} / \Delta^{PUCCH}_{shift} + 1) - 1 & \text{если } n^{(1,\tilde{p})}_{PUCCH} \geq c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift} \\
  \lfloor h_{\tilde{p}} / c \rfloor + \frac{(h_{\tilde{p}} \mod c) \cdot N'}{\Delta^{PUCCH}_{shift}} & \text{иначе}
 \end{cases} & \text{при } n_s \mod 2 = 1
\end{cases} \\
h_{\tilde{p}} = (n'_{\tilde{p}}(n_s - 1) + d) \mod (c \cdot N' / \Delta^{PUCCH}_{shift})
$$
 где 
  - `d = 2, c = 3` для normal CP, `d = 0, c = 2` для extended CP 
  - `\Delta^{PUCCH}_{shift}` идёт из параметра `deltaPUCCH-shift` в SIB2
  - `N^{(1)}_{cs}` идёт из параметра `nCS-AN` в SIB2
  - `N^{RB}_{sc} = 12`
  - `n^{(1,\tilde{p})}_{PUCCH}` - номер ресурса, который идёт из верхних уровней (а именно из DCI, совместно с SIB2 (поле `n1PUCCH-AN`) (там используется формула, которая состоит из двух параметров), но об этом в разделе про процедуры)

 Теперь давайте разбираться на что это вообще влияет и почему формула именно такая.
 1.1. Сначала разберемся с условием в формулах: `n^{(1,\tilde{p})}_{PUCCH} < c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift}`. Тут `c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift}` - общее количество доступных cyclic shift'ов для текущего PUCCH. 
  1.1.1. c - кол-во ортогональных кодов на один RB
  1.1.2. `N^{(1)}_{cs}` - кол-во используемых cyclic shift'ов в целом
  1.1.3. `\Delta^{PUCCH}_{shift}` - шаг между между cyclic shift'ами.
  1.1.4. Чтобы лучше понять, что это значит, обратимся опять к исходной формуле генерации `y`. В ней используется функция `r`, которая выдаёт каждый раз новый ортогональный код. Cyclic shift - это когда мы берем этот набор чисел и делаем так, что элемент под номером `n` становится элементом под номером `(n + m) \mod N^{PUCCH}_{seq}`, где m - как раз смещение. Так вот получается, что общее количество значений `m` - это `N^{(1)}_{cs}`, шаг между ними - это `\Delta^{PUCCH}_{shift}`, а `c` - общее количество возможных ортогональных кодов в одном RB. Отсюда и выходит, что значение `c \cdot N^{(1)}{cs}/\Delta^{PUCCH}{shift}` - это общее кол-во в целом доступных cyclic shift'ов для текущих выделенных ресурсов PUCCH для одного RB.
  1.1.5. И получается, что так как нам досутпно всего `c \cdot N^{(1)}{cs}/\Delta^{PUCCH}{shift}` cyclic shift'ов, то в один RB можно записать всего какое-то определённое значение различных данных. Поэтому если номер RB `n^{(1,\tilde{p})}_{PUCCH}` меньше чем общее кол-во cyclic shift'ов, мы можем назначать в этот RB данные напрямую, а если больше (когда, например, UE больше, чем ортогональных ресурсов), то надо идти обратно и назначать данные в предыдущие RB - за это отвечает `(n^{(1,\tilde{p})}_{PUCCH} - c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift}) \mod (c \cdot N^{RB}_{sc}/\Delta^{PUCCH}_{shift})`
 1.2. Теперь разберемся с назначением номера RB в случае, когда `n_s` нечетный. В этом случае используется такое выражение:

$$
\begin{cases}
  [c(n'_{\tilde{p}}(n_s - 1) + 1)] \mod (c \cdot N^{RB}_{sc} / \Delta^{PUCCH}_{shift} + 1) - 1 & \text{если } n^{(1,\tilde{p})}_{PUCCH} \geq c \cdot N^{(1)}_{cs}/\Delta^{PUCCH}_{shift} \\
  \lfloor h_{\tilde{p}} / c \rfloor + \frac{(h_{\tilde{p}} \mod c) \cdot N'}{\Delta^{PUCCH}_{shift}} & \text{иначе}
\end{cases}
$$
  1.2.1. Тут тоже формула разбита на две части. Рассмотрим первую. Она выполняется, если мы уже вышли за рамки ортогональных ресурсов. В таком случае берется предыдущий элемент массива номеров RB, к нему прибавляется 1, затем умножается на `c`, берется остаток от деления на общее число cyclic shift'ов и от этого отнимается 1. Эта операция создаёт больше разброса в выделении ресурсов для нечётных slot'ов, уменьшая тем самым интерференцию.
  1.2.2. Рассмотрим вторую часть. Она выполняется если мы ещё не вышли за рамки ортогональных ресурсов.
   1.2.2.1. `\lfloor h_{\tilde{p}} / c \rfloor` берет индекс группы ортогональных кодов в текущем RB. Т.е если у нас номер выделенного PRB - 18, то номер группы будет равен 6. 
   1.2.2.2. `h_{\tilde{p}} \mod c` - получает номер ортогонального кода внутри группы ортогональных кодов. 
   1.2.2.3. `N'` в этом случае будет равен `N^{(1)}_{cs}`, т.е общему кол-ву cyclic shift'ов.
   1.2.2.4. Если просуммировать полученные части и поделить вторую на шаг: `lfloor h_{\tilde{p}} / c \rfloor + \frac{(h_{\tilde{p}} \mod c) \cdot N'}{\Delta^{PUCCH}_{shift}}`, то мы получим новый уникальный индекс RB, который отличается от тех, которые находятся в чётных слотах. Такое разделение помогает уменьшить коллизии ресурсов с разных UE, а также увеличить разницу в частотах, что в общем уменьшает интерференцию.

 В итоге, это большое выражение для `n'_{\tilde{p}}(n_s)` преобразует номер PRB для номера слота `n_s`. Тут стоит понимать, что несколько UE могут занимать одни и те же ресурсы, поэтому и существует такая сложная процедура преобразования номера RB. Она помогает уменьшить риск коллизии (когда несколько UE используют одинаковые ресурсы и одинаковые ортогональные коды), увеличить разницу в частоте между разными UE, а также уменьшить интерференцию между UE.
 Эта формула используется в других формулах для генерации распределённых и уникальных параметров и не используется напрямую для назначения данным RB.

 2. `n^{(\tilde{p})}_{oc}(n_s)` - опять же, сначала сделаю математическое описание генерации этой последовательности:

$$
n^{(\tilde{p})}_{oc}(n_s) = \begin{cases} 
  \lfloor n'_{\tilde{p}}(n_s) \cdot \Delta^{PUCCH}_{shift} / N' \rfloor & \text{  при использовании normal CP} \\
  2 \cdot \lfloor n'_{\tilde{p}}(n_s) \cdot \Delta^{PUCCH}_{shift} / N' \rfloor & \text{ при использовании extended CP} \\
\end{cases}
$$
 
 При этом `N'` определяется как:

$$
N' = \begin{cases}
  N^{(1)}_{cs} & \text{если } n^{(1, \tilde{p})}_{PUCCH} < c \cdot N^{(1)}_{cs} / \Delta^{PUCCH}_{shift} \\
  N^{RB}_{sc} & \text{иначе}
\end{cases} 
$$
 
 2.1. Сначала разберёмся с `N'`:
  2.1.1. Если мы ещё не вышли за рамки ортогональных ресурсов, то оно будет равно значению `N^{(1)}_{cs}`, т.е кол-ву cyclic shift'ов в целом
  2.1.2. Если вышли, то `N^{RB}_{sc}`, т.е кол-ву subcarrier для RB (обычно 12).
  2.1.3. Таким образом, `N'` используется для адаптации к региону назначения ресурсов: если индекс RB ещё в пределах ортогональных cyclic shift'ов, то `N' = N^{(1)}_{cs}` — используем все доступные cyclic shift'ы. Если индекс вышел за пределы ортогональных ресурсов, то `N' = N^{RB}_{sc}` — используем все поднесущие RB для распределения ресурсов.
 2.2. Теперь разберемся с основным выражением для `n^{(\tilde{p})}_{oc}(n_s)`. Получение номера ортогонального кода осуществляется в зависимости от номера PRB `n'_{\tilde{p}}(n_s)` так как он предоставляет достаточно хорошее разделение пользователей в целом. Для получения номера ещё необходимо умножить его на `\frac{\Delta^{PUCCH}_{shift}}{N'}`. Тут это можно представить как набор `N'` cyclic shift'ов, разделённых между собой шагом `\Delta^{PUCCH}_{shift}`. При этом так как `\Delta^{PUCCH}_{shift}` может быть равен 1, 2, или 3, а `N' \leq 12` то получается, что мы в любом случае будем получать числа, меньшие 3. Именно поэтому после применения floor, мы получим значения 0, 1 или 2.

 Это выражение определяет индекс ортогонального кода `w_{n^{(\tilde{p})}_{oc}}(m)` из тех двух таблиц, которые я приводил ранее: (PHY PUCCH Format 1 Orthogonal Sequences) https://imgur.com/a/ptgfM4Z.

 3. Теперь разберемся с генерацией cyclic shift для `r`:  тот самый `\alpha_{\tilde{p}}(n_s, l)`. Сначала опять же запишу это математически:

$$
\alpha_{\tilde{p}}(n_s, l) = 2\pi \cdot n^{(\tilde{p})}_{cs}(n_s, l) / N^{RB}_{sc} \\
n^{(\tilde{p})}_{cs}(n_s, l) = \begin{cases}
 (n^{cell}_{cs}(n_s, l) + (n'_{\tilde{p}}(n_s) \cdot \Delta^{PUCCH}_{shift} + (n^{(\tilde{p})}_{oc}(n_s) \mod \Delta^{PUCCH}_{shift})) \mod N' ) \mod N^{RB}_{sc} & \text{для normal CP} \\
 (n^{cell}_{cs}(n_s, l) + (n'_{\tilde{p}}(n_s) \cdot \Delta^{PUCCH}_{shift} + n^{(\tilde{p})}_{oc}(n_s)/2) \mod N' ) \mod N^{RB}_{sc} & \text{для extended CP}
\end{cases} \\
n^{cell}_{cs}(n_s, l) = \sum^{7}_{i=0}{c(8N^{UL}_{symb} \cdot n_s + 8l + i)} \cdot 2^i, \ c_{init} = n^{RS}_{ID}
$$

  3.1. Рассмотрим сначала генерацию `\alpha`: формула определяет смещение по фазе для каждого слота `n_s` и символа `l`. Для этой формулы используется последовательность `n^{(\tilde{p})}_{cs}(n_s, l)`.
  3.2. Теперь рассмотрим `n^{cell}_{cs}(n_s, l)`. Здесь, `c(k)` - псевдорандомный набор чисел, который мы уже до этого много раз видели. `c_{init}` для него также указан, он равен `n^{RS}_{ID}`, который в свою очередь равен уже известному нам значению `N^{cell}_{ID}`, либо `N^{PUCCH}_{ID}`, который идёт из RRC Connection Reconfiguration, поле resourceToAddModList.pucch-ResourceId (о RRC позже). Эта последовательность гарантирует, что cyclic shift'ы UE, подключённых к разным вышкам будут более вероятно разными, так как она зависит от уникального идентификатора вышки.
  3.3. `n^{(\tilde{p})}_{cs}(n_s, l)` комбинирует в себе все рассмотренные прежде последовательности чисел и создаёт уникальную последовательность предсказуемых cyclic shift'ов, которая устойчива к интерференции как к устройствам, подключённым к одной и той же вышке, так и к устройствам, подключённым к другим вышкам.

На этой иллюстрации я обьеденил все, что было только что описано. Тут представлена полная процедура генерации символов `\zeta` для PUCCH format 1, 1a, 1b: (PHY PUCCH Format 1) https://imgur.com/a/ptgfM4Z.

Также я сделал код для генерации сигнала для этого канала, так будет воспринимать формулы гораздо проще:

```python
import numpy as np
from sequence.rs_sequence import generate_rs_sequence
from channels.pucch.common import get_n_cell_cs

N_PUCCH_seq = 12
N_RB_sc = 12
N_UL_symb = 7
N_PUCCH_SF = 4

modulation_tables = {
    "a": {
        (0): 1, (1): -1
    },
    "b": {
        (0, 0): 1, (0, 1): -1j,
        (1, 0): 1j, (1, 1): -1
    }
}

orthogonal_codes = {
    4: [
        np.array([1, 1, 1, 1]),
        np.array([1, -1, 1, -1]),
        np.array([1, -1, -1, 1]),
    ],
    3: [
        np.array([1, 1, 1]),
        np.array([1, np.exp(1j * 2 * np.pi / 3), np.exp(1j * 4 * np.pi / 3)]),
        np.array([1, np.exp(1j * 4 * np.pi / 3), np.exp(1j * 2 * np.pi / 3)]),
    ]
}


class Context:
    allocated_n_pucch: int
    N_cs: int
    delta_pucch_shift: int
    is_extended_cp: bool
    N_RS_ID: int

    def __init__(self, allocated_n_pucch, N_cs, delta_pucch_shift, is_extended_cp, N_RS_ID):
        self.allocated_n_pucch = allocated_n_pucch
        self.N_cs = N_cs
        self.delta_pucch_shift = delta_pucch_shift
        self.is_extended_cp = is_extended_cp
        self.N_RS_ID = N_RS_ID

def modulate(bits, format="a"):
    return modulation_tables[format][tuple(bits)]

def cyclic_shift(symb, alpha, antenna_ports):
    '''
     * symb specifies the modulated symbol "d(0)"
     * alpha specifies the cyclic shift for rs sequence
     * antenna_ports specifies the number of antenna ports "P"
    '''
    y = [0] * N_PUCCH_seq
    rs_sequence = generate_rs_sequence(N_PUCCH_seq, alpha, 0)

    for n in range(N_PUCCH_seq):
        y[n] = (1 / np.sqrt(antenna_ports)) * symb * rs_sequence[n]
    
    return y

def get_scrambling(n_s, context: Context):
    return 1 if get_n_p(n_s, context) % 2 == 0 else np.exp(1j * np.pi / 2)

def get_orthogonal_code(n_s, context: Context):
    return orthogonal_codes[N_PUCCH_SF][get_n_oc(n_s, context)]

def get_c(context: Context):
    return 3 if not context.is_extended_cp else 2

def get_cyclic_shift_resources(context: Context):
    total_cyclic_shifts = get_c(context) * context.N_cs / context.delta_pucch_shift
    is_in_orthogonal_resource = context.allocated_n_pucch < total_cyclic_shifts

    return (total_cyclic_shifts, is_in_orthogonal_resource)

def get_resource_N(context: Context):
    '''
     - generates N' for the current context
    '''
    _, is_in_orth_res = get_cyclic_shift_resources(context)
    return context.N_cs if is_in_orth_res else N_RB_sc

def get_n_p(n_s, context: Context):
    d = 2 if not context.is_extended_cp else 0
    c = get_c(context)
    total_cyclic_shifts, is_in_orthogonal_resource = get_cyclic_shift_resources(context)
    N = get_resource_N(context)

    if n_s % 2 == 0:
        if is_in_orthogonal_resource: return context.allocated_n_pucch
        return (context.allocated_n_pucch - total_cyclic_shifts) % total_cyclic_shifts
    
    h_p = (get_n_p(n_s - 1, context) + d) % total_cyclic_shifts
    if is_in_orthogonal_resource:
        return np.floor(h_p / c) + (N * (h_p % c) / context.delta_pucch_shift)
    
    return ((c * (get_n_p(n_s - 1, context) + 1)) % (total_cyclic_shifts + 1)) - 1

def get_n_oc(n_s, context: Context):
    multiplier = 1 if not context.is_extended_cp else 2
    return int(np.floor(get_n_p(n_s, context) * context.delta_pucch_shift / get_resource_N(context))) * multiplier

def get_n_cs(n_s, l, context: Context):
    n_cell_cs = get_n_cell_cs(n_s, l, context.N_RS_ID, N_UL_symb)
    n_p = get_n_p(n_s, context)
    n_oc = get_n_oc(n_s, context)
    N = get_resource_N(context)

    if not context.is_extended_cp:
        return (n_cell_cs + (n_p * context.delta_pucch_shift + (n_oc % context.delta_pucch_shift)) % N) % N_RB_sc

    return (n_cell_cs + (n_p * context.delta_pucch_shift + n_oc // 2) % N) % N_RB_sc

def get_alpha(n_s, l, context: Context):
    return 2 * np.pi * get_n_cs(n_s, l, context) / N_RB_sc

def modify_y(y, n_s, context: Context):
    zeta = [0] * (N_PUCCH_seq * N_PUCCH_SF * 2)
    for m_tick in range(2):
        for m in range(N_PUCCH_SF):
            for n in range(N_PUCCH_seq):
                orthogonal_code = get_orthogonal_code(n_s, context)
                value = get_scrambling(n_s, context) * orthogonal_code[m] * y[n]
                zeta[m_tick * N_PUCCH_SF * N_PUCCH_seq + m * N_PUCCH_seq + n] = value
    return zeta

if __name__ == "__main__":
    context = Context(
        allocated_n_pucch=3,
        N_cs=5,
        delta_pucch_shift=2,
        is_extended_cp=False,
        N_RS_ID=133
    )
    n_s = 0
    l = 0
    P = 1
    bits = (0, 1)

    modulated = modulate(bits, "b")
    alpha = get_alpha(n_s, l, context)
    y = cyclic_shift(modulated, alpha, 1)
    zeta = modify_y(y, n_s, context)

    print(zeta)
```

* 1.1.6.2.2. PUCCH Formats 2, 2a, 2b

Форматы PUCCH 2, 2a и 2b используются для передачи ровно 20 бит данных. 

Набор бит `b(0),\dots,b(19)` сначала проходит этап Scrambling согласно известной нам формуле: `\tilde{b}(i) = (b(i) + c(i)) \mod 2`, где `c` - псевдорандомная последовательность чисел, для которой `c_{init}` определяется следующим образом: `c_{init} = (\lfloor n_s / 2 \rfloor + 1) \cdot (2N^{cell}_{ID} + 1) \cdot 2^{16} + n_{RNTI}`.

После этого набор бит `\tilde{b}(0),\dots,\tilde{b}(19)` модулируется с помощью QPSK, в результате которого получается набор 10 комплексных чисел `d(0),\dots,d(9)` (в QPSK - 2 бита на один RE, поэтому 10).

После этого генерируется результат `\zeta` согласно формуле `\zeta^{(\tilde{p})}(N^{PUCCH}_{seq} \cdot n + i) = \frac{1}{\sqrt{P}} d(n) \cdot r^{(\alpha_{\tilde{p}},\delta)}_{u,v}(i)`, логика здесь точно такая же, как и для форматов 1, 1a, 1b. При этом `n=0,1,\dots,9` и `i = 0,1,\dots,N^{RB}_{sc} - 1`. Значение `N^{PUCCH}_{seq} = 12`, так же как и в 1, 1a, 1b.

Как вы уже могли заметить, здесь мы не генерируем промежуточный массив `y`, а сразу идём на генерацию готовых символов `\zeta`. Это из-за того, что в форматах 2, 2a и 2b нет ортогональных кодов.

`\alpha` генерируется в соответствии с генерацией 1, 1a, 1b: `\alpha_{\tilde{p}}(n_s, l) = 2 \pi \cdot n^{(\tilde{p})}_{cs}(n_s, l) / N^{RB}_{sc}`.

`n^{(\tilde{p})}_{cs}(n_s, l)` генерируется иначе: `n^{(\tilde{p})}_{cs}(n_s, l) = (n^{cell}_{cs}(n_s, l) + n'_{\tilde{p}}(n_s)) \mod N^{RB}_{sc}`. Тут формула проще: она содержит в себе `n^{cell}_{cs}(n_s, l)`, который генерируется также, как и для форматов 1, 1a, 1b и `n'_{\tilde{p}}(n_s)`. Идея в ней такая же: создать достаточно уникальную последовательность cyclic shift'ов, которая будет минимизировать интерференцию.

`n'_{\tilde{p}}(n_s)` генерируется немного иначе по сравнению с форматами 1, 1a, 1b: 

$$
n'_{\tilde{p}}(n_s) = \begin{cases}
 \begin{cases}
  n^{(2,\tilde{p})}_{PUCCH} \mod N^{RB}_{sc} & \text{если } n^{(2,\tilde{p})}_{PUCCH} < N^{RB}_{sc} N^{(2)}_{RB} \\
  (n^{(2,\tilde{p})}_{PUCCH} + N^{(1)}_{cs} + 1) \mod N^{RB}_{sc} & \text{иначе} 
 \end{cases} & \text{ если } n_s \mod 2 = 0 \\
 \begin{cases}
  ( N^{RB}_{sc} \cdot (n'_{\tilde{p}}(n_s - 1) + 1)) \mod (N^{RB}_{sc} + 1) - 1 & \text{если } n^{(2,\tilde{p})}_{PUCCH} < N^{RB}_{sc} N^{(2)}_{RB} \\
  (N^{RB}_{sc} - n^{(2,\tilde{p})}_{PUCCH} - 2) \mod N^{RB}_{sc} & \text{иначе}
 \end{cases} & \text{ если } n_s \mod 2 = 1
\end{cases}
$$

Тут
 - `N^{(2)}_{RB}` - идёт из поля `PUCCH-ConfigCommon.nRB-CQI` в SIB2.
 - `n^{(2,\tilde{p})}_{PUCCH}` - идёт из поля `CQI-ReportPeriodic.setup.cqi-PUCCH-ResourceIndex` в RRC Connection Reconfiguration.
 - `N^{(1)}_{cs}` - идёт из поля `PUCCH-ConfigCommon.nCS-AN` в SIB2.

Рассмотрим условие `n^{(2,\tilde{p})}_{PUCCH} < N^{RB}_{sc} N^{(2)}_{RB}`: тут часть `N^{RB}_{sc} N^{(2)}_{RB}` - это общее кол-во subcarrier'ов, выделенных под PUCCH format 2. Если `n^{(2,\tilde{p})}_{PUCCH}` меньше, то он находится внутри региона выделенных RB и `n^{(2,\tilde{p})}_{PUCCH}` используется напрямую. Иначе, к нему добавляется `N^{(1)}_{cs} + 1`. Это надо для того, чтобы избежать коллизий с format 1, 1a, 1b, ведь `N^{(1)}_{cs}` - кол-во cyclic shift'ов, использующихся для первого формата и добавляя этот параметр, мы как бы пропускаем значения, назначенные первому формату.

На этой иллюстрации я также собрал все формулы в месте: (PHY PUCCH Format 2) https://imgur.com/a/ptgfM4Z.

И реализация в коде будет выглядеть так:

```python
import numpy as np
import modulation, scrambling
from sequence.rs_sequence import generate_rs_sequence
from .common import get_n_cell_cs

N_PUCCH_seq = 12
N_RB_sc = 12
N_UL_symb = 7

class Context:
    def __init__(self, N_RS_ID: int, cqi_pucch_resourceIndex: int, nRB_CQI: int, nCS_AN: int):
        self.N_RS_ID = N_RS_ID
        self.cqi_pucch_resourceIndex = cqi_pucch_resourceIndex
        self.nRB_CQI = nRB_CQI
        self.nCS_AN = nCS_AN

def get_n_p(n_s, context: Context):
    is_in_region = context.cqi_pucch_resourceIndex < N_RB_sc * context.nRB_CQI
    if n_s % 2 == 0:
        if is_in_region: return context.cqi_pucch_resourceIndex % N_RB_sc
        return (context.cqi_pucch_resourceIndex + context.nCS_AN + 1) % N_RB_sc
    
    if is_in_region:
        return ((N_RB_sc * (get_n_p(n_s - 1, context) + 1)) % (N_RB_sc + 1)) - 1
    return (N_RB_sc - context.cqi_pucch_resourceIndex - 2) % N_RB_sc

def get_n_cs(n_s, l, context: Context):
    n_cell_cs = get_n_cell_cs(n_s, l, context.N_RS_ID)
    return (n_cell_cs + get_n_p(n_s, context)) % N_RB_sc

def get_alpha(n_s, l, context: Context):
    return 2 * np.pi * get_n_cs(n_s, l, context) / N_RB_sc

def cyclic_shift(d, n_s, l_start, antenna_ports, context: Context):
    zeta = np.zeros((10, N_RB_sc), dtype=complex)
    for n in range(10):
        for i in range(N_RB_sc):
            l = l_start + n
            rs_sequence = generate_rs_sequence(N_PUCCH_seq, get_alpha(n_s, l, context), 0)
            zeta[n, i] = (1 / np.sqrt(antenna_ports)) * d[n] * rs_sequence[i]
    return zeta

if __name__ == "__main__":
    N_cell_id = 133 
    context = Context(
        N_RS_ID=N_cell_id,
        cqi_pucch_resourceIndex=0,
        nRB_CQI=5,
        nCS_AN=6
    )
    n_s = 0
    l = 0
    n_rnti = 8

    bits = [0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0]
    
    c_init = (int(np.floor(n_s / 2)) + 1) * (2 * N_cell_id + 1) * (2 ** 16) + n_rnti
    scrambled = scrambling.scramble(bits, c_init)
    modulated = modulation.modulate_bits(scrambled, mu=2)
    zeta = cyclic_shift(modulated, n_s, l, 1, context)
    print(zeta)
```

* 1.1.6.2.3. PUCCH format 3

PUCCH format 3 используется для передачи 48 бит. Используется в основном для CoMP или Carrier Aggregation. Но об этом позже.

На вход поступает набор бит `b(0),\dots,b(M_{bit} - 1), \ M_{bit} = 48` и над ним осуществляется Scrambling в соотвествии со Scrambling'ом для форматов 2, 2a, 2b.

Модуляция символов `\tilde{b}(0),\dots,\tilde{b}(M_{bit} - 1)` тоже проходит также, как и для форматов 2, 2a, 2b.

Этот формат использует ортогональные коды для получения `\zeta`, поэтому добавляется ещё один этап (такое мы уже видели в формате 1, 1a, 1b). Над набором смодулированных символов `d(0),\dots,d(M_{symb} - 1)` осуществляется следующая операция:

$$
y^{(\tilde{p})}_n(i) = \begin{cases}
  w_{n^{(\tilde{p})}_{oc,0}}(\bar{n}) \cdot e^{j \pi \lfloor n^{cell}_{cs}(n_s, l) / 64 \rfloor / 2} \cdot d(i) & \text{при } n < N^{PUCCH}_{SF,0} \\
  w_{n^{(\tilde{p})}_{oc,1}}(\bar{n}) \cdot e^{j \pi \lfloor n^{cell}_{cs}(n_s, l) / 64 \rfloor / 2} \cdot d(N^{RB}_{sc} + i) & \text{иначе}
\end{cases}, \\
\bar{n} = n \mod N^{PUCCH}_{SF,0} \\
n = 0,\dots,N^{PUCCH}_{SF,0} + N^{PUCCH}_{SF,1} - 1 \\
i = 0,\dots,N^{RB}_{sc} - 1
$$

Где:
 - `N^{PUCCH}_{SF,0} = N^{PUCCH}_{SF,1} = 5` при использовании normal PUCCH format 3
 - `N^{PUCCH}_{SF,0} = 5, N^{PUCCH}_{SF,1} = 4` при использовании shortened PUCCH format 3 

Давайте сначала разберемся с этой формулой:
 - `N^{PUCCH}_{SF,0}` и `N^{PUCCH}_{SF,1}` - кол-во SC-FDMA символов, использующихся для передачи первой или второй группы соответсвенно.
 - `\bar{n} = n \mod N^{PUCCH}_{SF,0}` - индекс внутри ортогонального кода для текущего символа `n`. Он гарантирует, что ортогональный код повторяется каждые `N^{PUCCH}_{SF,0}` символов.
 - К каждому символу применяется уникальное для соты смещение по фазе (оно уникальное для соты благодаря `n^{cell}_{cs}`. При этом деление на 64 и floor ограничевает возможное кол-во смещений. Эта операция нужна для (псевдо)рандомизации фазовых смещений для каждой вышки, уменьшая шанс интерференции UE, подключенных к разным вышкам.
 - При этом модулированные символы разбиты на две группы. Для первой (`n < N^{PUCCH}_{SF,0}`) мы берем `d(i)`, а для второй (`n \geq N^{PUCCH}_{SF,0}`) `d(N^{RB}_{sc} + i)`. Разбиение на две группы позволяет PUCCH format 3 отправлять большее кол-во данных на двух группах символов (и двух группах ортогональных кодов).

Номер вектора для ортогонального кода `n_{oc}` генерируется следующим образом:

$$
n^{(\tilde{p})}_{oc,0} = n^{(3, \tilde{p})}_{PUCCH} \mod N^{PUCCH}_{SF,1} \\
n^{(\tilde{p})}_{oc,1} = \begin{cases} 
  (3n^{(\tilde{p})}_{oc, 0}) \mod N^{PUCCH}_{SF,1} & \text{при } N^{PUCCH}_{SF,1} = 5 \\
  n^{(\tilde{p})}_{oc,0} \mod N^{PUCCH}_{SF,1} & \text{иначе}
\end{cases}
$$

Тут видно, что `n^{(\tilde{p})}_{oc,1}` зависит от `n^{(\tilde{p})}_{oc,0}`. При этом в случае normal PUCCH format 3 `n^{(\tilde{p})}_{oc,1}` будет всегда отличаться от `n^{(\tilde{p})}_{oc,0}` благодаря умножению на 3. Это нужно чтобы гарантировать разные ортогональные коды, даже в случае, если одинаковые ресурсы используются для двух групп. Такое разделение не нужно для shortened PUCCH format 3, так как сам набор кодов для него меньше. 

Наборы ортогональных кодов записаны в таблице 36.211 5.4.2A-1: (PHY PUCCH format 3 orthogonal sequences) https://imgur.com/a/ptgfM4Z.

После получения набора значений `y^{(\tilde{p})}_n(i)`, к нему применяется cyclic shift следующим образом: `\tilde{y}^{(\tilde{p})}_n(i) = y^{(\tilde{p})}_n(i) \cdot ((i + n^{cell}_{cs}(n_s, l)) \mod N^{RB}_{sc})`. Видно, что номер cyclic shift'а также генерируется с помощью `n^{cell}_{cs}`, т.е набора чисел, уникального для вышки. Это помогает ещё больше уменьшить вероятность интерференции сигналов, особенно для UE, находящимся в разных сотах.

Затем набор `\tilde{y}^{(\tilde{p})}_n(i)` проходит Transform Precoding: `\zeta^{(\tilde{p})}(n \cdot N^{RB}_{sc} + k) = \frac{1}{\sqrt{P \times N^{RB}_{sc}}} \sum^{N^{RB}_{sc} - 1}_{i = 0}{\tilde{y}^{(\tilde{p})}_n(i) e^{-j \frac{2 \pi ik}{N^{RB}_{sc}}}}`, при `k = 0,\dots,N^{RB}_{sc} - 1`, `n = 0,\dots,N^{PUCCH}_{SF,0} + N^{PUCCH}_{SF,1} - 1`. Тут видна уже знакомая нам операция, которую мы рассматривали в PUSCH. Поменялся только коэфициент, здесь он равен произведению кол-ва антенн на кол-во subcarrier'ов в RB. Он позволяет распределить энергию между всеми антеннами и subcarrier'ами (так как для батарее выгоднее, чтобы сумма мощности всех антенн была константной). Тут это используется, так как в других случаях (например PUSCH), мощность антенн контроллируется сначала TPC, а потом уже коэфициентами DFT (именно TPC играет решающую роль, коэфициент там лишь распределяет энергию между уровнями).

И снова, я сделал иллюстрацию, где указал все использующиеся формулы для этого формата: (PHY PUCCH Format 3) https://imgur.com/a/ptgfM4Z.

Ну и реализация в коде:

```python
import numpy as np
import scrambling, modulation
from ..common import transform_precoding
from .common import get_n_cell_cs

N_PUCCH_seq = 12
N_RB_sc = 12
N_UL_symb = 7

class Context:
    def __init__(self, N_RS_ID: int, is_shortened: bool, allocated_prb: int):
        self.N_RS_ID = N_RS_ID
        self.is_shortened = is_shortened
        self.allocated_prb = allocated_prb

        self.N_PUCCH_SF_0 = 5
        self.N_PUCCH_SF_1 = 4 if is_shortened else 5

orth_exp_code = lambda code: [np.exp(1j * 2 * c * np.pi / 5) for c in code]

orthogonal_codes = [
    {
        5: np.array([1, 1, 1, 1, 1]),
        4: np.array([1, 1, 1, 1])
    },
    {
        5: np.array(orth_exp_code([0, 1, 2, 3, 4])),
        4: np.array([1, -1, 1, -1])
    },
    {
        5: np.array(orth_exp_code([0, 2, 4, 1, 3])),
        4: np.array([1, 1, -1, -1])
    },
    {
        5: np.array(orth_exp_code([0, 3, 1, 4, 2])),
        4: np.array([1, -1, -1, 1])
    },
    {
        5: np.array(orth_exp_code([0, 4, 3, 2, 1]))
    }
]

def get_y_n(d, n_s, l_start, context: Context):
    total_rbs = context.N_PUCCH_SF_0 + context.N_PUCCH_SF_1
    y = np.zeros((total_rbs, N_RB_sc), dtype=complex)

    for i in range(N_RB_sc):
        for n in range(total_rbs):
            l = l_start + n
            n_bar = n % context.N_PUCCH_SF_0
            n_cell_cs = get_n_cell_cs(n_s, l, context.N_RS_ID, N_UL_symb)
            phase = np.exp(1j * np.pi * np.floor(n_cell_cs / 64) / 2)
            n_oc_0 = context.allocated_prb % context.N_PUCCH_SF_1
            if n < context.N_PUCCH_SF_0:
                y[n, i] = orthogonal_codes[n_oc_0][context.N_PUCCH_SF_1][n_bar] * phase * d[i]
            else:
                n_oc_1 = ((3 * n_oc_0) if context.N_PUCCH_SF_1 == 5 else n_oc_0) % context.N_PUCCH_SF_1
                y[n, i] = orthogonal_codes[n_oc_1][context.N_PUCCH_SF_1][n_bar] * phase * d[i + N_RB_sc]
    
    return y


def cyclic_shift(y: np.ndarray, n_s: int, l_start: int, context: Context):
    total_rbs = context.N_PUCCH_SF_0 + context.N_PUCCH_SF_1
    tilde_y = np.zeros_like(y)

    for i in range(N_RB_sc):
        for n in range(total_rbs):
            n_cell_cs = get_n_cell_cs(n_s, l_start + n, context.N_RS_ID, N_UL_symb)
            tilde_y[n, i] = y[n, i] * ((i + n_cell_cs) % N_RB_sc)

    return tilde_y

if __name__ == "__main__":
    def to_bits(n: int, length: int):
        binary = bin(n)[2:].rjust(length, "0")
        return [int(b) for b in binary]

    N_cell_id = 133
    n_rnti = 9
    context = Context(
        N_RS_ID=N_cell_id,
        is_shortened=False,
        allocated_prb=0
    )
    n_s = 0
    l = 0
    antenna_ports = 1
    bits = [
        *to_bits(5, 8),
        *to_bits(99, 8),
        *to_bits(72, 8),
        *to_bits(65, 8),
        *to_bits(162, 8),
        *to_bits(243, 8),
    ]

    c_init = (int(np.floor(n_s / 2)) + 1) * (2 * N_cell_id + 1) * (2 ** 16) + n_rnti

    scrambled = scrambling.scramble(bits, c_init)
    modulated = modulation.modulate_bits(bits, mu=2)
    orthogonal_spread = get_y_n(modulated, n_s, l, context)
    cyclic_shifted = cyclic_shift(orthogonal_spread, n_s, l, context)
    precoded = transform_precoding(cyclic_shifted, context.N_PUCCH_SF_0 + context.N_PUCCH_SF_1, N_RB_sc, 1 / np.sqrt(antenna_ports * N_RB_sc))

    print(precoded)
```

* 1.1.6.2.4. PUCCH Format 4

PUCCH format 4 используется для отправки UCI, HARQ-ACK, SR и CSI Report, если они занимают больше 22 бит. (про них позже, главное, что больше 22 бит).

```
b(0),\dots,b(M_{bit} - 1)              
           │                           
           │                           
           ▼                           
 ┌───────────────────┐                 
 │                   │                 
 │    Scrambling     │                 
 │                   │                 
 └─────────┬─────────┘                 
           │ \tilde{b}(i)              
           ▼                           
 ┌───────────────────┐                 
 │                   │                 
 │    Modulation     │                 
 │                   │                 
 └─────────┬─────────┘                 
           │ d(0),\dots,d(M_{symb} - 1)
           ▼                           
 ┌───────────────────┐                 
 │     Transform     │                 
 │     Precoding     │                 
 │                   │                 
 └───────────────────┘                 
```

Для этого формата производятся операции (в данном порядке): Scrambling, Modulation, Transform Precoding. Отличается от Format 3 только Transform Precoding. И то только коэфициентами и переменными. Поэтому взглянем только на Transform Precoding:

$$
\zeta^{(\tilde{p})}(l \cdot M^{PUCCH4}_{sc} + k) = \frac{1}{\sqrt{M^{PUCCH4}_{sc}}} \sum^{M^{PUCCH4}_{sc} -1}_{i=0}{d(l \cdot M^{PUCCH4}_{sc} + i)}e^{-j\frac{\pi i k}{M^{PUCCH4}_{sc}}} \\
k = 0,\dots,M^{PUCCH4}_{sc} - 1, \\
l = 0,\dots,N^{PUCCH}_{0} + N^{PUCCH}_{1} - 1
$$

Стоит сразу отметить, что PUCCH format 4 работает только с одной антенной, т.е `\tilde{p} = 0`.

При этом параметры `N^{PUCCH}_{0}, N^{PUCCH}_{1}` даны в таблице 36.211 5.4.2C-1: (PHY PUCCH Formats 4,5 N_PUCCH_m) https://imgur.com/a/ptgfM4Z. Сумма этих параметров - кол-во групп, на которые были разбиты смодулированные символы d(i). Это разбиение отражено в формуле как получение элемента как будто из двумерной матрицы `d` со сторонами `N^{PUCCH}_{0} + N^{PUCCH}_{1}` рядов и `M^{PUCCH4}_{sc}` столбцов: `l \cdot M^{PUCCH4}_{sc} + i`.

Ещё можно было заметить параметр `M^{PUCCH4}_{sc}`. Его можно получить следующим образом: `M^{PUCCH4}_{sc} = M^{PUCCH4}_{RB} \times N^{RB}_{sc}`. Тут `M^{PUCCH4}_{RB}` равен числу RB, выделенных для текущей передачи PUCCH format 4. Чтобы понять откуда `M^{PUCCH4}_{RB}` идёт, обратимся к спецификации 36.213. В тексте 10.1.1 указано, что надо смотреть на таблицу 10.1.1-2:

```
╔══════════════════════════════╦══════════════╗
║ numberOfPRB-format4          ║ M PUCCH4 RB  ║
╠══════════════════════════════╬══════════════╣
║ 0                            ║      1       ║
║ 1                            ║      2       ║
║ 2                            ║      3       ║
║ 3                            ║      4       ║
║ 4                            ║      5       ║
║ 5                            ║      6       ║
║ 6                            ║      8       ║
║ 7                            ║  Reserved    ║
╚══════════════════════════════╩══════════════╝
```

Параметр `numberOfPRB-format4` описан не в последнем релизе 36.331 (откуда я беру описания SIB2). Он описан в релизе 36.331 13.5.0 и находится в поле `PUCCH-Config.PUCCH-ConfigDedicated.pucch-Format.format4.format4-resourceConfiguration.numberOfPRB-format4` в SIB2.

Для этого формата сделал только реализацию в коде (тут очень много повторяющихся частей, поэтому нет смысла делать иллюстрацию):

```python
import numpy as np
import modulation, scrambling
from ..common import transform_precoding

N_PUCCH_seq = 12
N_RB_sc = 12
N_UL_symb = 7

class Context:
    def __init__(self, N_RS_ID: int, is_shortened: bool, is_extended_cp: bool, M_PUCCH4_RB: int):
        self.N_RS_ID = N_RS_ID
        self.is_shortened = is_shortened
        self.is_extended_cp = is_extended_cp
        self.M_PUCCH4_RB = M_PUCCH4_RB
        self.M_PUCCH4_SC = M_PUCCH4_RB * N_RB_sc

        if is_extended_cp and not is_shortened: self.N_PUCCH_0 = self.N_PUCCH_1 = 5
        if is_extended_cp and is_shortened: 
            self.N_PUCCH_0 = 5 
            self.N_PUCCH_1 = 4
        
        if not is_extended_cp and not is_shortened: self.N_PUCCH_0 = self.N_PUCCH_1 = 6
        if not is_extended_cp and is_shortened:
            self.N_PUCCH_0 = 0
            self.N_PUCCH_1 = 5

if __name__ == "__main__":
    N_cell_id = 133
    n_rnti = 9
    context = Context(
        N_RS_ID=N_cell_id,
        is_shortened=False,
        is_extended_cp=False,
        M_PUCCH4_RB=1
    )
    n_s = 0
    l = 0
    antenna_ports = 1
    M_bit = context.M_PUCCH4_RB * N_RB_sc * (context.N_PUCCH_0 + context.N_PUCCH_1) * 2
    bits = np.random.binomial(1, 0.5, size=(M_bit))

    c_init = (int(np.floor(n_s / 2)) + 1) * (2 * N_cell_id + 1) * (2 ** 16) + n_rnti

    scrambled = scrambling.scramble(bits, c_init)
    modulated = modulation.modulate_bits(bits, mu=2)
    precoded = transform_precoding(modulated, context.N_PUCCH_0 + context.N_PUCCH_1, context.M_PUCCH4_SC, 1 / np.sqrt(context.M_PUCCH4_SC))

    print(precoded)
```

При этом я использую `transform_precoding` в таком виде:

```python
import numpy as np

def transform_precoding(x: np.ndarray, rows: int, cols: int, coef: int):
    grouped = x.reshape((rows, cols))
    y = np.zeros_like(x, dtype=complex)

    for l in range(grouped.shape[0]):
        fft = np.fft.fft(grouped[l])
        y[l * cols : (l + 1) * cols] = coef * fft

    return y
```

* 1.1.6.2.5. PUCCH Format 5

PUCCH Format 5 используется в тех же случаях, что и format 4. Однако у него есть преимущество: он поддерживает ортогональные коды. Т.е позволяет запихнуть больше данных в одно и то же кол-во RE.

```
b(0),\dots,b(M_{bit} - 1)              
           │                           
           │                           
           ▼                           
 ┌───────────────────┐                 
 │                   │                 
 │    Scrambling     │                 
 │                   │                 
 └─────────┬─────────┘                 
           │ \tilde{b}(i)              
           ▼                           
 ┌───────────────────┐                 
 │                   │                 
 │    Modulation     │                 
 │                   │                 
 └─────────┬─────────┘                 
           │ d(0),\dots,d(M_{symb} - 1)
           ▼                           
 ┌───────────────────┐                 
 │     Block-wise    │                 
 │     Spreading     │                 
 │                   │                 
 └─────────┬─────────┘                 
           │ y_n(i)                    
           ▼                           
 ┌───────────────────┐                 
 │     Transform     │                 
 │     Precoding     │                 
 │                   │                 
 └───────────────────┘                 
```

Сначала над набором входных бит производятся уже знакомые операции Scrambling и Modulation. Они производятся в полном соотвествии с format 4. Однако после этих этапов и перед Transform Precoding добавляется ещё один немаловажный этап: Block-wise Spreading.

Сначала запишу его математически:

$$
y_n(i) = w_{n_{oc}}(i) \cdot d(\frac{(i \mod N^{RB}_{sc}) + n \cdot N^{RB}_{sc}}{N^{PUCCH}_{SF}}) \\
n = 0,\dots,N^{PUCCH}_{0} + N^{PUCCH}_{1} - 1 \\ 
i = 0,\dots,N^{RB}_{sc}
$$

Где:
 - `N^{PUCCH}_{SF} = 2`
 - `N^{PUCCH}_{0}, N^{PUCCH}_{1}` получаются также, как и для format 4.
 - `n_{oc}` - индекс в таблице 36.211 5.4.2C-2: (PHY PUCCH Format 5 orthogonal sequences) https://imgur.com/a/ptgfM4Z. Для этого параметра нет формулы для генерации. Номер ортогонального кода идёт из RRC Connection Reconfiguration, поля `PUCCH-Config.cdm-index-format5` (он тоже описан в 36.331 13.5.0, т.е не в последней ревизии). 

Тут получение индекса `\frac{(i \mod N^{RB}_{sc}) + n \cdot N^{RB}_{sc}}{N^{PUCCH}_{SF}}` - это такая же операция индексации по матрице. Она говорит о том, что перед этим этапом `d` разбивается на `N^{PUCCH}_{0} + N^{PUCCH}_{1}` групп. Каждая группа занимает своё место по subcarrier'ам, т.е по одному SC-FDMA символу. Применение ортонгонального кода также осуществляется по одному SC-FDMA символу. Причем в формуле, деление на `N^{PUCCH}_{SF}` определяет сколько символов будут назначены в один и тот же элемент. В случае 2, их количество тоже будет равно двум. Это происходит из-за того, что при переводе в int, ровно для половины чисел индекс не будет меняться. 

После этого полученные символы проходят через уже известный этап Transform Precoding, в котором отличается только коэфициент:

$$
\zeta^{(\tilde{p})}(n \cdot N^{RB}_{sc} + k) = \frac{1}{\sqrt{N^{RB}_{sc}}} \sum^{N^{RB}_{sc} - 1}_{i=0}{y_n(i)e^{-j\frac{2 \pi ik}{N^{RB}_{sc}}}} \\
k = 0,\dots,N^{RB}_{sc} - 1 \\
n = 0,\dots,N^{PUCCH}_{0} + N^{PUCCH}_{1} - 1 
$$

Этот формат также работает только с одной антенной, т.е `\tilde{p} = 0`.

Для этого формата я уже сделал иллюстрацию: (PHY PUCCH Format 5) https://imgur.com/a/ptgfM4Z.

И реализацию в коде:

```python
import numpy as np
import modulation, scrambling
from ..common import transform_precoding
from .format_4 import Context

N_PUCCH_seq = 12
N_RB_sc = 12
N_UL_symb = 7
N_PUCCH_SF = 2

orthogonal_codes = [
    [1] * 12,
    [1] * 6 + [-1] * 6
]

def block_wise_spread(d: np.ndarray, n_oc, context: Context):
    y = np.zeros((context.N_PUCCH_0 + context.N_PUCCH_1, N_RB_sc), dtype=complex)
    for n in range(y.shape[0]):
        for i in range(N_RB_sc):
            y[n, i] = orthogonal_codes[n_oc][i] * d[int((i + n * N_RB_sc) / N_PUCCH_SF)]
    return y

if __name__ == "__main__":
    N_cell_id = 133
    n_rnti = 9
    context = Context(
        N_RS_ID=N_cell_id,
        is_shortened=False,
        is_extended_cp=False,
        M_PUCCH4_RB=1
    )
    n_s = 0
    l = 0
    n_oc = 0
    M_bit = N_RB_sc * (context.N_PUCCH_0 + context.N_PUCCH_1)
    bits = np.random.binomial(1, 0.5, size=(M_bit))

    c_init = (int(np.floor(n_s / 2)) + 1) * (2 * N_cell_id + 1) * (2 ** 16) + n_rnti

    scrambled = scrambling.scramble(bits, c_init)
    modulated = modulation.modulate_bits(bits, mu=2)
    spread = block_wise_spread(modulated, n_oc, context)
    precoded = transform_precoding(spread, context.N_PUCCH_0 + context.N_PUCCH_1, N_RB_sc, 1 / np.sqrt(context.M_PUCCH4_SC))

    print(precoded)
```

* 1.1.6.2.6. PUCCH Mapping to resource elements

Resource Element Mapper берет на вход символы `\zeta^{(\tilde{p})}(0),\dots,\zeta^{(\tilde{p})}(i)` и назначает каждый к RE в позиции (k, l) на антенне с номером `p`, при этом сначала увеличивается `k`, затем `l`, затем slot.

Для назначения RE в PUCCH используются номера PRB внутри одного slot. Определяется номер следующим образом:

```
n_{PRB}(n_s) = \begin{cases}
 \lfloor m/2 \rfloor & \text{если } (m + (n_s \mod 2)) \mod 2 = 0 \\
 N^{UL}_{RB} - \lfloor \frac{1}{2}m \rfloor -1 & \text{иначе}
\end{cases}
```

Из формулы видно, что она зависит от номера слота `n_s` и меняет своё поведение в зависимости от чётности этого параметра. В частности, если `n_s \mod 2 = 0` (т.е четный), то весь PUCCH будет находиться внизу RG (т.е расположение по частоте будет ниже в RG). Иначе, весь PUCCH будет находится вверху RG. Это я отобразил на диаграмме: (PHY PUCCH Resource Element Mapping) https://imgur.com/a/ptgfM4Z.

Теперь надо понять как генерируется `m` и как он влияет на положение PUCCH. Генерация `m` зависит от формата PUCCH:

 1. Для форматов 1, 1a, 1b используется следующая формула:

$$
m = \begin{cases}
 N^{(2)}_{RB} & \text{если } n^{(1,\tilde{p})}_{PUCCH} < c \cdot N^{(1)}_{cs} / \Delta^{PUCCH}_{shift} \\
 \biggl\lfloor \frac{n^{(1, \tilde{p})}}{c \cdot N^{RB}_{sc} / \Delta^{PUCCH}_{shift}} - 1 \biggl\rfloor + \lceil N^{(1)}_{cs} / 8 \rceil + N^{(2)}_{RB} & \text{иначе}
\end{cases}
$$
  Где:
   - `N^{(2)}_{RB}` - кол-во RB, выделенных для передачи PUCCH format 2, 2a, 2b.
   - `c = 3` при normal CP, `c = 2` при extended CP.

 Тут опять же, формула разбита на две части. Одна (первая) выполняется если выделенные ресурсы (т.е индекс ресурсов PUCCH format 1) находятся в рамках ортогональных ресурсов. Другими словами, если не требуется больше RE для отправки данных, то мы просто используем RB конца PUCCH format 2 как начало format 1.
 Если же `n^{(1,\tilde{p})}_{PUCCH}` выходит за рамки ортогональных ресурсов, то выполняется вторая часть формулы:
  - `\biggl\lfloor \frac{n^{(1, \tilde{p})}}{c \cdot N^{RB}_{sc} / \Delta^{PUCCH}_{shift}} - 1 \biggl\rfloor` определяет кол-во регионов с досутпными ортогональными ресурсами которые мы уже использовали.
  - `\lceil N^{(1)}_{cs} / 8 \rceil` необходим для большего разделения PUCCH format 1 от других каналов.

 2. Для форматов 2, 2a, 2b используется довольно простая формула: `m = \lfloor n^{(2, \tilde{p})}_{PUCCH} / N^{RB}_{sc} \rfloor`. Она выполняет простую функцию: дать возможность к последовательному назначению PRB.
 3. Для формата 3 используется также простая формула: `m = \lfloor n^{(3, \tilde{p})}_{PUCCH} / N^{PUCCH}_{SF,0}`. Логика такая же.
 4. Для формата 5 используется формула ещё проще: `m = n^{(5)}_{PUCCH}`, где `n^{(5)}_{PUCCH}` - выделенный индекс PUCCH.

Вы могли заметить, что здесь не было формата 4. Для него действует немного другая процедура:

$$
n_{PRB}(n_s) = \begin{cases}
  m & \text{при } n_s \mod 2 = 0 \\
  N^{UL}_{RB} - m - 1 & \text{иначе}
\end{cases}
$$

Тут `m` напрямую генерируется от `n^{(4)}_{PUCCH}`: `m = n^{(4)}_{PUCCH},\dots,n^{(4)}_{PUCCH} + M^{PUCCH4}_{RB} - 1`. Он меняет своё значение в рамках заданного региона в зависимости от `n_s`. А именно увеличивает смещение, т.е чем больше `n_s`, тем больше `m`. Математически можно записать это так: `m = n^{(4)}_{PUCCH} + n_s, m < n^{(4)}_{PUCCH} + M^{PUCCH4}_{RB}`.

Такое изменение от дефолтного метода является видом оптимизации. Подразумевается, что деление m на два уже включено в `n^{(4)}_{PUCCH}` (т.е в PRB номер для format 4)

На следующей иллюстрации я изобразил как будет выглядеть распределение форматов PUCCH для самой распростронённой конфигурации (тут я ещё подписал каким параметрам соотвествуют какие переменные в формулах):

```c
// -- SIB2 --

ul-Bandwidth = 50; // N^{UL}_{RB} = 50 (для BW=10 MHz)

PUCCH-ConfigCommon = {
    deltaPUCCH-Shift = ds2; // \Delta^{PUCCH}_{shift} = 2
    nRB-CQI          = 1;  // N^{(2)}_{RB} = 1 (кол-во RB, выделенных для format 2/2a/2b)
    nCS-AN           = 0;  // N^{(1)}_{cs} = 0 (кол-во cyclic shift'ов для RE форматов 1/1a/1b)
    
    pucch-Format5-r13 = {
        format5-enabled = TRUE;
    };
}

// -- RRCConnectionReconfiguration-NB --

CQI-ReportPeriodic = {
  cqi-PUCCH-ResourceIndex = 0; // n^{(2, \tilde{p})}_{PUCCH} (resource index для форматов 2/2a/2b)
}

PUCCH-Format3-Conf = {
  twoAntennaPortActivatedPUCCH-Format3-r13 = {
    n3PUCCH-AN-ListP1-r13 = {
      0, // n^{(3, \tilde{p})}_{PUCCH} = 0 (resource index для формата 3)
    }
  }
}

Format4-resource-r13 = {
  startingPRB-format4-r13 = 2; // n^{(4)}_{PUCCH} = 2 (resource index для формата 4)
  numberOfPRB-format4-r13 = 1; // M^{PUCCH4}_{RB} = 1 (кол-во RB для формата 4)
};

Format5-resource-r13 = {
  startingPRB-format5 = 3; // n^{(5)}_{PUCCH} = 3 (resource index для формата 5)
  cdm-index-format5-r13 = 0; // n_{oc} (номер ортогонального кода для формата 5)
}

CP-Type       = Normal CP;
N_RB_sc       = 12;
N_UL_symb     = 7;
Antenna-Ports = 1; // кол-во антенн = 1
```

(PHY PUCCH Resource Element Mapping Default Configuration) https://imgur.com/a/ptgfM4Z.

-------

Вот мы и разобрались с Uplink каналами. На очереди сигналы и PRACH. Сначала думаю разберемся с сигналами, а PRACH оставим напоследок в разборе физического уровня. В PRACH выполняется именно процедура инициализации устройства, поэтому этот канал станет хорошей стартовой точкой в процедуры и транспортный уровень.

---------------------------------------------------------------------------------

Заметки для себя:
 1. PUSCH Frequency Hopping
 2. PUCCH amplitude scaling factor `\Beta_{PUCCH}` для управления мощностью (P_{PUCCH}). 36.211 5.4.3 и 36.213 5.1.2.1.
 3. SPUCCH

---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

#### 1.1.7. Signals

В LTE, как мы уже выяснили, существует несколько каналов: PDCCH, PDSCH, PBCH, PUSCH, PUCCH, ... . Они используются для передачи непосредственно информации (т.е набора бит), которая идёт из верхних уровней. Другими словами, к каждому физическому каналу подключён какой-нибудь канал из транспортного и логического уровня. В этот раз мы будем разбираться с сигналами. Сигналы не передают никакой конкретной информации и существуют только в физическом уровне. Они могут использоваться для декодирования сигнала (DMRS), синхронизции (PSS, SSS) и получения данных о качестве канала и мощности передачи (UE Specific, Cell specific RS, SRS).

Как и для каналов, для сигналов также действует разделение на направления downlink и uplink. Разберемся с каждым из них.

##### 1.1.7.1. Downlink Signals

В направлении downlink существует девять различных сигналов:
 - Reference Signals:
  * Cell-specific Reference Signal (CRS)
  * MBSFN Reference Signal
  * UE-Specific Reference Signal (PDSCH DMRS)
  * EPDCCH DMRS, MPDCCH DMRS
  * Positioning Reference Signal (PRS)
  * Channel State Information Reference Signal (CSI-RS)
 - Synchronization Signals:
  * Primary Synchronization Signal (PSS)
  * Secondary Synchronization Signal (SSS)
  * Resynchronization Signal (RSS)

###### 1.1.7.1.1. CRS

CRS - основной сигнал в LTE. Он позволяет UE определять RSRP и RSRQ (т.е качество канала), а следовательно и осуществлять функции мобильности (т.е устройство именно благодаря этому сигналу знает когда стоит переключиться на следующую вышку, другими словами произвести Handover). 

 * 1.1.7.1.1.1. Sequence Generation

Набор символов на отправку для этого сигнала создаётся согласно следующей формуле (её стоит запомнить, она будет переиспользоваться для некоторых других сигналов, меняться будут лишь зависимости):

$$
r_{l,n_s}(m) = \frac{1}{\sqrt{2}}(1 - 2 \cdot c(2m)) + j\frac{1}{\sqrt{2}}(1 - 2 \cdot c(2m + 1)) \\
m = 0,\dots,2N^{max,DL}_{RB} - 1
$$

Где:
 - `n_s` - номер слота в frame.
 - `l` - номер OFDM символа в slot.
 - `N^{max,DL}_{RB} = 110` - максимально возможный Bandwith, выраженный в кол-ве RB.

Для псевдорандомной последовательности `c` (которую мы рассматривали ранее), `c_{init}` генерируется следующим образом: `c_{init} = 2^{10} \cdot (7 \cdot (n_s + 1) + l + 1) \cdot (2 N^{cell}_{ID} + 1) + 2 N^{cell}_{ID} + N_{cp}`. При этом `N_{cp} = 1` для normal CP и `N_{cp} = 0` для extended CP.

Теперь давайте разберёмся с формулой `r`. Тут можно заметить, что она состоит из двух частей: действительной и комплексной. Так как `c(i)` может быть равен либо 0, либо 1, то часть `1 - 2c(2m)` генерирует значения, равные либо 1, либо -1. Такая процедура позволяет сгенерировать значения во всех четырех четвертях комплексной плоскости. Умножение на `1/sqrt(2)` лишь нормализует точки для генерации IQ параметров.

c_init устроен таким образом, чтобы дать устройству возможность декодировать (или сверить) CRS. Он использует только те параметры, которые доступны UE на момент считывания CRS: ID вышки и тип CP.

Лучше понять сигнал `r` поможет иллюстрация: (PHY CRS Constellation) https://imgur.com/a/ptgfM4Z. Тут видно, что он принимает только 4 возможных значения в соотвествии с описанием.

 * 1.1.7.1.1.2. RE Mapping

Каждый элемент массива `r(m)` назначается в один RE `\alpha` следующим образом: `\alpha^{(p)}_{k,l} = r_{l,n_s}(m')`. Это выражение означает, что для каждого OFDM символа в одном slot, RE с номером subcarrier `k` получает элемент массива `r` с номером `m'`. При этом `m' = m + N^{max,DL}_{RB} - N^{DL}_{RB}`, а `m = 0,\dots,2N^{DL}_{RB} - 1`. Тут каждое значение `m` преобразуется в `m'` чтобы соответсвовать размеру массива `r`.

При этом на `l` и `k` (OFDM символ и subcarrier соответсвенно) накладываются следующие ограничения:

$$
l = \begin{cases}
 0,N^{DL}_{symb} - 3 & \text{если } p \in \{0,1\} \\
 1 & \text{если } p \in \{2,3\} \\
\end{cases} \\
k = 6m + (v + v_{shift}) \bmod 6,
$$

При этом параметры `v` и `v_{shift}` генерируются на основе ID вышки, номера антенны и OFDM символа:

$$
v = \begin{cases}
 0 & \text{если } (p = 0 \text{ и } l = 0) \text{ или } (p = 1 \text{ и } l \neq 0) \\
 3 & \text{если } (p = 0 \text{ и } l \neq 0) \text{ или } (p = 1 \text{ и } l = 0) \\ 
 3(n_s \mod 2) & \text{если } p = 2 \\
 3 + 3(n_s \mod 2) & \text{если } p = 3 \\
\end{cases} \\ 
v_{shift} = N^{cell}_{ID} \mod 6
$$

Эти формулы говорят о том, что (при `N^{cell}_{ID} = 0`, `p = 0`):
 - По частоте CRS будет появляться в 0 и 6 subcarrier в RB если `l = 0` и в 3 и 9 subcarrier в RB если `l != 0`.
 - CRS будет появляться в каждом 0 и 4 (`N^{DL}_{symb} - 3`) OFDM символе slot'а.
 - CRS будет следовать такому распределению каждый slot.
 - При изменении ID вышки `N^{cell}_{ID}` сигнал будет смещаться вверх по частоте
 - При изменении номера антенны `p` сигнал также будет менять положение по частоте. Причем изменения, как можно заметить, подобраны таким образом, чтобы в один момент лишь одна антенна вещала сигнал в данном RE. Другими словами, параметры (k, l) уникальны для каждой из 4-х антенн. 

Сначала приведу код для данного сигнала, потом рассмотрим визуально как выглядит распределение по RG:

```python
import numpy as np
from context.context import Context
from context.constants import N_max_DL_RB
from channels.symbol import ReferenceSignal, Reserved
from sequence.pseudo_random import get_pseudorandom_sequence
from matplotlib import pyplot as plt

crs_sequences = {}

def get_rs_sequence(c_init, length):
    c = get_pseudorandom_sequence(c_init, 2*length)
    return [ 
        (1/np.sqrt(2)) * (1 - 2 * c[2*m]) + 1j * (1/np.sqrt(2)) * (1 - 2 * c[2*m + 1])
        for m in range(length)
    ]

def generate_crs_sequence(n_s, l, context: Context):
    N_cp = 0 if context.is_extended_cp else 1
    c_init = (2**10) * (7 * (n_s + 1) + l + 1) * (2 * context.physical_cell_id + 1) + 2 * context.physical_cell_id + N_cp 
    return get_rs_sequence(c_init, 2 * N_max_DL_RB)

def get_crs_sequence(n_s, l, context: Context):
    crs_sequence = crs_sequences.get((n_s, l), None)
    if not crs_sequence:
        crs_sequence = generate_crs_sequence(n_s, l, context)
        crs_sequences[(n_s, l)] = crs_sequence
    return crs_sequence

def get_subcarrier_shift_v(antenna_port, l, n_s):
    if (antenna_port == 0 and l == 0) or (antenna_port == 1 and l != 0): return 0
    if (antenna_port == 0 and l != 0) or (antenna_port == 1 and l == 0): return 3
    if antenna_port == 2: return 3 * (n_s % 2)
    if antenna_port == 3: return 3 + 3 * (n_s % 2)

def map_crs(antenna_port: int, context: Context):
    possible_l = [1] if antenna_port in (2, 3) else [0, context.N_DL_symb - 3]
    v_shift = context.physical_cell_id % 6
    symbols = []
    for n_s in range(context.nof_slots):
        for l in possible_l:
            for m in range(2 * context.N_DL_RB):
                crs_sequence = get_crs_sequence(n_s, l, context)
                m_tick = m + N_max_DL_RB - context.N_DL_RB
                v = get_subcarrier_shift_v(antenna_port, l, n_s)
                k = 6*m + (v + v_shift) % 6
                current_symb = crs_sequence[m_tick]
                global_l = n_s * context.N_DL_symb + l

                context.dl_resource_grid.map_re(antenna_port, k, global_l, ReferenceSignal(current_symb))
                for other_antenna_port in range(context.antenna_ports):
                    if other_antenna_port != antenna_port:
                        context.dl_resource_grid.map_re(other_antenna_port, k, global_l, Reserved(0))

                symbols.append(current_symb)
    return symbols
```

При изменении ID вышки CRS будет смещаться по частоте: (PHY CRS RE N_cell_id Mapping) https://imgur.com/a/ptgfM4Z.

А на разных антеннах CRS будет всегда занимать разные RE: (PHY CRS RE antenna_port Mapping) https://imgur.com/a/ptgfM4Z.

---------------------------------------------------------------------------------

Заметки для себя:
 1. Discovery Signal